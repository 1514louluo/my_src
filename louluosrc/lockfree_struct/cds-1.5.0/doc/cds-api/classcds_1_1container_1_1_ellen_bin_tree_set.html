<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>cds: cds::container::EllenBinTreeSet&lt; GC, Key, T, Traits &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">cds
   &#160;<span id="projectnumber">1.5.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecds.html">cds</a></li><li class="navelem"><a class="el" href="namespacecds_1_1container.html">container</a></li><li class="navelem"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html">EllenBinTreeSet</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">cds::container::EllenBinTreeSet&lt; GC, Key, T, Traits &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__cds__nonintrusive__set.html">Set</a> &#124; <a class="el" href="group__cds__nonintrusive__tree.html">Tree</a> &#124; <a class="el" href="group__cds__nonintrusive__priority__queue.html">Priority queue</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Set based on Ellen's et al binary search tree.  
 <a href="classcds_1_1container_1_1_ellen_bin_tree_set.html#details">More...</a></p>

<p><code>#include &lt;cds/container/ellen_bintree_set_impl.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cds::container::EllenBinTreeSet&lt; GC, Key, T, Traits &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcds_1_1container_1_1_ellen_bin_tree_set.png" usemap="#cds::container::EllenBinTreeSet&lt; GC, Key, T, Traits &gt;_map" alt=""/>
  <map id="cds::container::EllenBinTreeSet&lt; GC, Key, T, Traits &gt;_map" name="cds::container::EllenBinTreeSet&lt; GC, Key, T, Traits &gt;_map">
<area href="classcds_1_1intrusive_1_1_ellen_bin_tree.html" title="Ellen&#39;s et al binary search tree. " alt="cds::intrusive::EllenBinTree&lt; GC, Key, T, Traits &gt;" shape="rect" coords="0,0,316,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1a8df10b866b08781de4b0a7acfde4b4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1a8df10b866b08781de4b0a7acfde4b4"></a>
typedef GC&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html#a1a8df10b866b08781de4b0a7acfde4b4">gc</a></td></tr>
<tr class="memdesc:a1a8df10b866b08781de4b0a7acfde4b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Garbage collector. <br/></td></tr>
<tr class="separator:a1a8df10b866b08781de4b0a7acfde4b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26a5bef24e38f738a26cf0a8d6434baa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a26a5bef24e38f738a26cf0a8d6434baa"></a>
typedef Key&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html#a26a5bef24e38f738a26cf0a8d6434baa">key_type</a></td></tr>
<tr class="memdesc:a26a5bef24e38f738a26cf0a8d6434baa"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of a key stored in internal nodes; key is a part of <code>value_type</code> <br/></td></tr>
<tr class="separator:a26a5bef24e38f738a26cf0a8d6434baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a316b2a66574539658016af669432d5a3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a316b2a66574539658016af669432d5a3"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html#a316b2a66574539658016af669432d5a3">value_type</a></td></tr>
<tr class="memdesc:a316b2a66574539658016af669432d5a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of value stored in the binary tree <br/></td></tr>
<tr class="separator:a316b2a66574539658016af669432d5a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3fe5fc5433ec91aa2a8aa2d25d81d35"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae3fe5fc5433ec91aa2a8aa2d25d81d35"></a>
typedef Traits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html#ae3fe5fc5433ec91aa2a8aa2d25d81d35">options</a></td></tr>
<tr class="memdesc:ae3fe5fc5433ec91aa2a8aa2d25d81d35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits template parameter. <br/></td></tr>
<tr class="separator:ae3fe5fc5433ec91aa2a8aa2d25d81d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88bebc25599a44f3d75038c79124347d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a88bebc25599a44f3d75038c79124347d"></a>
typedef implementation_defined&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html#a88bebc25599a44f3d75038c79124347d">key_comparator</a></td></tr>
<tr class="memdesc:a88bebc25599a44f3d75038c79124347d"><td class="mdescLeft">&#160;</td><td class="mdescRight">key compare functor based on <a class="el" href="structcds_1_1opt_1_1compare.html" title="[type-option] Option setter for key comparing ">opt::compare</a> and <a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate ">opt::less</a> option setter. <br/></td></tr>
<tr class="separator:a88bebc25599a44f3d75038c79124347d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad94343ea7ec63c11c3881a9ce55bf23b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad94343ea7ec63c11c3881a9ce55bf23b"></a>
typedef base_class::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html#ad94343ea7ec63c11c3881a9ce55bf23b">item_counter</a></td></tr>
<tr class="memdesc:ad94343ea7ec63c11c3881a9ce55bf23b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counting policy used. <br/></td></tr>
<tr class="separator:ad94343ea7ec63c11c3881a9ce55bf23b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09befc3944be847542f6d50ed65b420d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09befc3944be847542f6d50ed65b420d"></a>
typedef base_class::memory_model&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html#a09befc3944be847542f6d50ed65b420d">memory_model</a></td></tr>
<tr class="memdesc:a09befc3944be847542f6d50ed65b420d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory ordering. See <a class="el" href="structcds_1_1opt_1_1memory__model.html" title="[type-option] Option setter for C++ memory model ">cds::opt::memory_model</a> option. <br/></td></tr>
<tr class="separator:a09befc3944be847542f6d50ed65b420d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a087863f3eaa3f0551b05496b9f06c38c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a087863f3eaa3f0551b05496b9f06c38c"></a>
typedef base_class::stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html#a087863f3eaa3f0551b05496b9f06c38c">stat</a></td></tr>
<tr class="memdesc:a087863f3eaa3f0551b05496b9f06c38c"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal statistics type <br/></td></tr>
<tr class="separator:a087863f3eaa3f0551b05496b9f06c38c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af45a1099459b7e7f92873a37c7a821c8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af45a1099459b7e7f92873a37c7a821c8"></a>
typedef options::key_extractor&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html#af45a1099459b7e7f92873a37c7a821c8">key_extractor</a></td></tr>
<tr class="memdesc:af45a1099459b7e7f92873a37c7a821c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">key extracting functor <br/></td></tr>
<tr class="separator:af45a1099459b7e7f92873a37c7a821c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba131686778a46c164048714a6ac9ab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ba131686778a46c164048714a6ac9ab"></a>
typedef options::allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html#a7ba131686778a46c164048714a6ac9ab">allocator_type</a></td></tr>
<tr class="memdesc:a7ba131686778a46c164048714a6ac9ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator for leaf nodes. <br/></td></tr>
<tr class="separator:a7ba131686778a46c164048714a6ac9ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32d2f85c8e8df0bccdc43a6d0b7deb6b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a32d2f85c8e8df0bccdc43a6d0b7deb6b"></a>
typedef base_class::node_allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html#a32d2f85c8e8df0bccdc43a6d0b7deb6b">node_allocator</a></td></tr>
<tr class="memdesc:a32d2f85c8e8df0bccdc43a6d0b7deb6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal node allocator. <br/></td></tr>
<tr class="separator:a32d2f85c8e8df0bccdc43a6d0b7deb6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1daa0dbe874a3fe679f257e7bbff6730"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1daa0dbe874a3fe679f257e7bbff6730"></a>
typedef <br class="typebreak"/>
base_class::update_desc_allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html#a1daa0dbe874a3fe679f257e7bbff6730">update_desc_allocator</a></td></tr>
<tr class="memdesc:a1daa0dbe874a3fe679f257e7bbff6730"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update descriptor allocator. <br/></td></tr>
<tr class="separator:a1daa0dbe874a3fe679f257e7bbff6730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html">cds::intrusive::EllenBinTree&lt; GC, Key, T, Traits &gt;</a></td></tr>
<tr class="memitem:a413c08fbf97b94fe58b1a16fb43fdc30 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a413c08fbf97b94fe58b1a16fb43fdc30"></a>
typedef GC&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#a413c08fbf97b94fe58b1a16fb43fdc30">gc</a></td></tr>
<tr class="memdesc:a413c08fbf97b94fe58b1a16fb43fdc30 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Garbage collector used. <br/></td></tr>
<tr class="separator:a413c08fbf97b94fe58b1a16fb43fdc30 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e4edbd33aad5489ef524d53cff9cfd6 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e4edbd33aad5489ef524d53cff9cfd6"></a>
typedef Key&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#a0e4edbd33aad5489ef524d53cff9cfd6">key_type</a></td></tr>
<tr class="memdesc:a0e4edbd33aad5489ef524d53cff9cfd6 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of a key stored in internal nodes; key is a part of <code>value_type</code> <br/></td></tr>
<tr class="separator:a0e4edbd33aad5489ef524d53cff9cfd6 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3131f31b2cbbfd725105ae9ca8c99e6 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae3131f31b2cbbfd725105ae9ca8c99e6"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#ae3131f31b2cbbfd725105ae9ca8c99e6">value_type</a></td></tr>
<tr class="memdesc:ae3131f31b2cbbfd725105ae9ca8c99e6 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of value stored in the binary tree <br/></td></tr>
<tr class="separator:ae3131f31b2cbbfd725105ae9ca8c99e6 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab10e40ca22ebc24dc38f93391cf6e595 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab10e40ca22ebc24dc38f93391cf6e595"></a>
typedef Traits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#ab10e40ca22ebc24dc38f93391cf6e595">options</a></td></tr>
<tr class="memdesc:ab10e40ca22ebc24dc38f93391cf6e595 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits template parameter. <br/></td></tr>
<tr class="separator:ab10e40ca22ebc24dc38f93391cf6e595 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34ab97b2c2f144699075d594832321de inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a34ab97b2c2f144699075d594832321de"></a>
typedef options::hook&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#a34ab97b2c2f144699075d594832321de">hook</a></td></tr>
<tr class="memdesc:a34ab97b2c2f144699075d594832321de inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">hook type <br/></td></tr>
<tr class="separator:a34ab97b2c2f144699075d594832321de inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c599dec5e7bec7b60cd0850ffacdd0a inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c599dec5e7bec7b60cd0850ffacdd0a"></a>
typedef hook::node_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#a3c599dec5e7bec7b60cd0850ffacdd0a">node_type</a></td></tr>
<tr class="memdesc:a3c599dec5e7bec7b60cd0850ffacdd0a inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">node type <br/></td></tr>
<tr class="separator:a3c599dec5e7bec7b60cd0850ffacdd0a inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af131f27b7d0df25edc1a58538e067ad4 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af131f27b7d0df25edc1a58538e067ad4"></a>
typedef options::disposer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#af131f27b7d0df25edc1a58538e067ad4">disposer</a></td></tr>
<tr class="memdesc:af131f27b7d0df25edc1a58538e067ad4 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">leaf node disposer <br/></td></tr>
<tr class="separator:af131f27b7d0df25edc1a58538e067ad4 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99ab0b8087d1c74e8d37ff544cb290d8 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a99ab0b8087d1c74e8d37ff544cb290d8"></a>
typedef implementation_defined&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#a99ab0b8087d1c74e8d37ff544cb290d8">key_comparator</a></td></tr>
<tr class="memdesc:a99ab0b8087d1c74e8d37ff544cb290d8 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">key compare functor based on <a class="el" href="structcds_1_1opt_1_1compare.html" title="[type-option] Option setter for key comparing ">opt::compare</a> and <a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate ">opt::less</a> option setter. <br/></td></tr>
<tr class="separator:a99ab0b8087d1c74e8d37ff544cb290d8 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac23bedac61a72afb4716acd97d19bc29 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac23bedac61a72afb4716acd97d19bc29"></a>
typedef <a class="el" href="structcds_1_1intrusive_1_1get__node__traits.html">get_node_traits</a><br class="typebreak"/>
&lt; <a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#ae3131f31b2cbbfd725105ae9ca8c99e6">value_type</a>, <a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#a3c599dec5e7bec7b60cd0850ffacdd0a">node_type</a>, <a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#a34ab97b2c2f144699075d594832321de">hook</a> &gt;<br class="typebreak"/>
::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#ac23bedac61a72afb4716acd97d19bc29">node_traits</a></td></tr>
<tr class="memdesc:ac23bedac61a72afb4716acd97d19bc29 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node traits. <br/></td></tr>
<tr class="separator:ac23bedac61a72afb4716acd97d19bc29 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643a24fcfeb9821e7fce2015d3dc3c15 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a643a24fcfeb9821e7fce2015d3dc3c15"></a>
typedef options::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#a643a24fcfeb9821e7fce2015d3dc3c15">item_counter</a></td></tr>
<tr class="memdesc:a643a24fcfeb9821e7fce2015d3dc3c15 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counting policy used. <br/></td></tr>
<tr class="separator:a643a24fcfeb9821e7fce2015d3dc3c15 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2a2b6f26d13004e53ce5530deb32284 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2a2b6f26d13004e53ce5530deb32284"></a>
typedef options::memory_model&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#aa2a2b6f26d13004e53ce5530deb32284">memory_model</a></td></tr>
<tr class="memdesc:aa2a2b6f26d13004e53ce5530deb32284 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory ordering. See <a class="el" href="structcds_1_1opt_1_1memory__model.html" title="[type-option] Option setter for C++ memory model ">cds::opt::memory_model</a> option. <br/></td></tr>
<tr class="separator:aa2a2b6f26d13004e53ce5530deb32284 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace4cf6d51a59d88758d6d161edbb81be inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace4cf6d51a59d88758d6d161edbb81be"></a>
typedef options::stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#ace4cf6d51a59d88758d6d161edbb81be">stat</a></td></tr>
<tr class="memdesc:ace4cf6d51a59d88758d6d161edbb81be inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal statistics type <br/></td></tr>
<tr class="separator:ace4cf6d51a59d88758d6d161edbb81be inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f8ca8da5433a67785ff3befc5fea04 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab3f8ca8da5433a67785ff3befc5fea04"></a>
typedef options::key_extractor&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#ab3f8ca8da5433a67785ff3befc5fea04">key_extractor</a></td></tr>
<tr class="memdesc:ab3f8ca8da5433a67785ff3befc5fea04 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">key extracting functor <br/></td></tr>
<tr class="separator:ab3f8ca8da5433a67785ff3befc5fea04 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72952c5677354f3a186e6ae5eba66235 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a72952c5677354f3a186e6ae5eba66235"></a>
typedef options::node_allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#a72952c5677354f3a186e6ae5eba66235">node_allocator</a></td></tr>
<tr class="memdesc:a72952c5677354f3a186e6ae5eba66235 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal node allocator. <br/></td></tr>
<tr class="separator:a72952c5677354f3a186e6ae5eba66235 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e46282c3ad09c1839b778769c506a16 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e46282c3ad09c1839b778769c506a16"></a>
typedef <br class="typebreak"/>
options::update_desc_allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#a1e46282c3ad09c1839b778769c506a16">update_desc_allocator</a></td></tr>
<tr class="memdesc:a1e46282c3ad09c1839b778769c506a16 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update descriptor allocator. <br/></td></tr>
<tr class="separator:a1e46282c3ad09c1839b778769c506a16 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7f1b42a1984a4c3d39dd50565e584ed3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f1b42a1984a4c3d39dd50565e584ed3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html#a7f1b42a1984a4c3d39dd50565e584ed3">EllenBinTreeSet</a> ()</td></tr>
<tr class="memdesc:a7f1b42a1984a4c3d39dd50565e584ed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br/></td></tr>
<tr class="separator:a7f1b42a1984a4c3d39dd50565e584ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41c6b6ceb171c4220dd71fc6e5f8b7f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41c6b6ceb171c4220dd71fc6e5f8b7f0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html#a41c6b6ceb171c4220dd71fc6e5f8b7f0">~EllenBinTreeSet</a> ()</td></tr>
<tr class="memdesc:a41c6b6ceb171c4220dd71fc6e5f8b7f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the set. <br/></td></tr>
<tr class="separator:a41c6b6ceb171c4220dd71fc6e5f8b7f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1300b9b363b7bc86e1d7c5018bb7a064"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:a1300b9b363b7bc86e1d7c5018bb7a064"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html#a1300b9b363b7bc86e1d7c5018bb7a064">insert</a> (Q const &amp;val)</td></tr>
<tr class="memdesc:a1300b9b363b7bc86e1d7c5018bb7a064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a1300b9b363b7bc86e1d7c5018bb7a064">More...</a><br/></td></tr>
<tr class="separator:a1300b9b363b7bc86e1d7c5018bb7a064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a30bcb9a89999dfaff7c0be67c0488"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:aa8a30bcb9a89999dfaff7c0be67c0488"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html#aa8a30bcb9a89999dfaff7c0be67c0488">insert</a> (Q const &amp;val, Func f)</td></tr>
<tr class="memdesc:aa8a30bcb9a89999dfaff7c0be67c0488"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#aa8a30bcb9a89999dfaff7c0be67c0488">More...</a><br/></td></tr>
<tr class="separator:aa8a30bcb9a89999dfaff7c0be67c0488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33f548baddc1e809c80adb1617ce7866"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:a33f548baddc1e809c80adb1617ce7866"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html#a33f548baddc1e809c80adb1617ce7866">ensure</a> (const Q &amp;val, Func func)</td></tr>
<tr class="memdesc:a33f548baddc1e809c80adb1617ce7866"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that the item exists in the set.  <a href="#a33f548baddc1e809c80adb1617ce7866">More...</a><br/></td></tr>
<tr class="separator:a33f548baddc1e809c80adb1617ce7866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe640538319de2de64353ba15ab5c76c"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:abe640538319de2de64353ba15ab5c76c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html#abe640538319de2de64353ba15ab5c76c">emplace</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:abe640538319de2de64353ba15ab5c76c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts data of type <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html#a316b2a66574539658016af669432d5a3">value_type</a> constructed with <code>std::forward&lt;Args&gt;(args)...</code>  <a href="#abe640538319de2de64353ba15ab5c76c">More...</a><br/></td></tr>
<tr class="separator:abe640538319de2de64353ba15ab5c76c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31135b8edf573295cdfab47db77af8d0"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:a31135b8edf573295cdfab47db77af8d0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html#a31135b8edf573295cdfab47db77af8d0">erase</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:a31135b8edf573295cdfab47db77af8d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete <code>key</code> from the set.  <a href="#a31135b8edf573295cdfab47db77af8d0">More...</a><br/></td></tr>
<tr class="separator:a31135b8edf573295cdfab47db77af8d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad165ef7c14badc28f4a8071019396043"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less &gt; </td></tr>
<tr class="memitem:ad165ef7c14badc28f4a8071019396043"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html#ad165ef7c14badc28f4a8071019396043">erase_with</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:ad165ef7c14badc28f4a8071019396043"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set using <code>pred</code> predicate for searching.  <a href="#ad165ef7c14badc28f4a8071019396043">More...</a><br/></td></tr>
<tr class="separator:ad165ef7c14badc28f4a8071019396043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba00d852182556fc1176f2dfeecef53c"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:aba00d852182556fc1176f2dfeecef53c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html#aba00d852182556fc1176f2dfeecef53c">erase</a> (Q const &amp;key, Func f)</td></tr>
<tr class="memdesc:aba00d852182556fc1176f2dfeecef53c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete <code>key</code> from the set.  <a href="#aba00d852182556fc1176f2dfeecef53c">More...</a><br/></td></tr>
<tr class="separator:aba00d852182556fc1176f2dfeecef53c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7721e0d6f69ebd2b7cfe83b75e37f395"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:a7721e0d6f69ebd2b7cfe83b75e37f395"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html#a7721e0d6f69ebd2b7cfe83b75e37f395">erase_with</a> (Q const &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:a7721e0d6f69ebd2b7cfe83b75e37f395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set using <code>pred</code> predicate for searching.  <a href="#a7721e0d6f69ebd2b7cfe83b75e37f395">More...</a><br/></td></tr>
<tr class="separator:a7721e0d6f69ebd2b7cfe83b75e37f395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82348054bfe47e9b7b49c3f7ca235167"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html#a82348054bfe47e9b7b49c3f7ca235167">extract_min</a> (<a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html#a316b2a66574539658016af669432d5a3">value_type</a> &amp;dest)</td></tr>
<tr class="memdesc:a82348054bfe47e9b7b49c3f7ca235167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an item with minimal key from the set.  <a href="#a82348054bfe47e9b7b49c3f7ca235167">More...</a><br/></td></tr>
<tr class="separator:a82348054bfe47e9b7b49c3f7ca235167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdb98987d7c719340caae238ddb66554"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:abdb98987d7c719340caae238ddb66554"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html#abdb98987d7c719340caae238ddb66554">extract_min</a> (Q &amp;dest, Func f)</td></tr>
<tr class="memdesc:abdb98987d7c719340caae238ddb66554"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an item with minimal key from the set.  <a href="#abdb98987d7c719340caae238ddb66554">More...</a><br/></td></tr>
<tr class="separator:abdb98987d7c719340caae238ddb66554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a9f654c49d9aaa5e00be99a54033d48"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html#a0a9f654c49d9aaa5e00be99a54033d48">extract_max</a> (<a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html#a316b2a66574539658016af669432d5a3">value_type</a> &amp;dest)</td></tr>
<tr class="memdesc:a0a9f654c49d9aaa5e00be99a54033d48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an item with maximal key from the set.  <a href="#a0a9f654c49d9aaa5e00be99a54033d48">More...</a><br/></td></tr>
<tr class="separator:a0a9f654c49d9aaa5e00be99a54033d48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad16225a3950290b06694df10becdb760"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:ad16225a3950290b06694df10becdb760"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html#ad16225a3950290b06694df10becdb760">extract_max</a> (Q &amp;dest, Func f)</td></tr>
<tr class="memdesc:ad16225a3950290b06694df10becdb760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an item with maximal key from the set.  <a href="#ad16225a3950290b06694df10becdb760">More...</a><br/></td></tr>
<tr class="separator:ad16225a3950290b06694df10becdb760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad1b0d393299bd62119e6a0187bb65c"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:a7ad1b0d393299bd62119e6a0187bb65c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html#a7ad1b0d393299bd62119e6a0187bb65c">find</a> (Q &amp;val, Func f)</td></tr>
<tr class="memdesc:a7ad1b0d393299bd62119e6a0187bb65c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code>.  <a href="#a7ad1b0d393299bd62119e6a0187bb65c">More...</a><br/></td></tr>
<tr class="separator:a7ad1b0d393299bd62119e6a0187bb65c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a712236f343bc55e40dceee73875e0308"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:a712236f343bc55e40dceee73875e0308"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html#a712236f343bc55e40dceee73875e0308">find_with</a> (Q &amp;val, Less pred, Func f)</td></tr>
<tr class="memdesc:a712236f343bc55e40dceee73875e0308"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code> using <code>pred</code> predicate for searching.  <a href="#a712236f343bc55e40dceee73875e0308">More...</a><br/></td></tr>
<tr class="separator:a712236f343bc55e40dceee73875e0308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d0828399485ca77dec429898dbdd273"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:a6d0828399485ca77dec429898dbdd273"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html#a6d0828399485ca77dec429898dbdd273">find</a> (Q const &amp;val, Func f)</td></tr>
<tr class="memdesc:a6d0828399485ca77dec429898dbdd273"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code>.  <a href="#a6d0828399485ca77dec429898dbdd273">More...</a><br/></td></tr>
<tr class="separator:a6d0828399485ca77dec429898dbdd273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8503f12ff72fe5739fe5a8cf94c39393"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:a8503f12ff72fe5739fe5a8cf94c39393"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html#a8503f12ff72fe5739fe5a8cf94c39393">find_with</a> (Q const &amp;val, Less pred, Func f)</td></tr>
<tr class="memdesc:a8503f12ff72fe5739fe5a8cf94c39393"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code> using <code>pred</code> predicate for searching.  <a href="#a8503f12ff72fe5739fe5a8cf94c39393">More...</a><br/></td></tr>
<tr class="separator:a8503f12ff72fe5739fe5a8cf94c39393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c211116cbfa7cd894fe7ff88525f75b"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:a7c211116cbfa7cd894fe7ff88525f75b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html#a7c211116cbfa7cd894fe7ff88525f75b">find</a> (Q const &amp;val)</td></tr>
<tr class="memdesc:a7c211116cbfa7cd894fe7ff88525f75b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code>.  <a href="#a7c211116cbfa7cd894fe7ff88525f75b">More...</a><br/></td></tr>
<tr class="separator:a7c211116cbfa7cd894fe7ff88525f75b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30875b982377a268abcff448819c4ef3"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less &gt; </td></tr>
<tr class="memitem:a30875b982377a268abcff448819c4ef3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html#a30875b982377a268abcff448819c4ef3">find_with</a> (Q const &amp;val, Less pred)</td></tr>
<tr class="memdesc:a30875b982377a268abcff448819c4ef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code> using <code>pred</code> predicate for searching.  <a href="#a30875b982377a268abcff448819c4ef3">More...</a><br/></td></tr>
<tr class="separator:a30875b982377a268abcff448819c4ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a182706f8c7c47c19da5b0727f71d3d06"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html#a182706f8c7c47c19da5b0727f71d3d06">clear</a> ()</td></tr>
<tr class="memdesc:a182706f8c7c47c19da5b0727f71d3d06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the set (non-atomic)  <a href="#a182706f8c7c47c19da5b0727f71d3d06">More...</a><br/></td></tr>
<tr class="separator:a182706f8c7c47c19da5b0727f71d3d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3006cfb9220b46b857958e346cbaca3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af3006cfb9220b46b857958e346cbaca3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html#af3006cfb9220b46b857958e346cbaca3">empty</a> () const </td></tr>
<tr class="memdesc:af3006cfb9220b46b857958e346cbaca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the set is empty. <br/></td></tr>
<tr class="separator:af3006cfb9220b46b857958e346cbaca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf3a6e00a7ef226568e97f3d3653870d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html#acf3a6e00a7ef226568e97f3d3653870d">size</a> () const </td></tr>
<tr class="memdesc:acf3a6e00a7ef226568e97f3d3653870d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns item count in the set.  <a href="#acf3a6e00a7ef226568e97f3d3653870d">More...</a><br/></td></tr>
<tr class="separator:acf3a6e00a7ef226568e97f3d3653870d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ac3781594ce4e3529a501285d1995ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ac3781594ce4e3529a501285d1995ec"></a>
<a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html#a087863f3eaa3f0551b05496b9f06c38c">stat</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html#a5ac3781594ce4e3529a501285d1995ec">statistics</a> () const </td></tr>
<tr class="memdesc:a5ac3781594ce4e3529a501285d1995ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const reference to internal statistics. <br/></td></tr>
<tr class="separator:a5ac3781594ce4e3529a501285d1995ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c8d47aa8f13a24b00ff5604ae4c3dbf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html#a0c8d47aa8f13a24b00ff5604ae4c3dbf">check_consistency</a> () const </td></tr>
<tr class="memdesc:a0c8d47aa8f13a24b00ff5604ae4c3dbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks internal consistency (not atomic, not thread-safe)  <a href="#a0c8d47aa8f13a24b00ff5604ae4c3dbf">More...</a><br/></td></tr>
<tr class="separator:a0c8d47aa8f13a24b00ff5604ae4c3dbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html">cds::intrusive::EllenBinTree&lt; GC, Key, T, Traits &gt;</a></td></tr>
<tr class="memitem:a384d04dfebb1bb014ab08a6884131536 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a384d04dfebb1bb014ab08a6884131536"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#a384d04dfebb1bb014ab08a6884131536">EllenBinTree</a> ()</td></tr>
<tr class="memdesc:a384d04dfebb1bb014ab08a6884131536 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br/></td></tr>
<tr class="separator:a384d04dfebb1bb014ab08a6884131536 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf3e82fcef7ec85b4338e4b0f317b8d inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adbf3e82fcef7ec85b4338e4b0f317b8d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#adbf3e82fcef7ec85b4338e4b0f317b8d">~EllenBinTree</a> ()</td></tr>
<tr class="memdesc:adbf3e82fcef7ec85b4338e4b0f317b8d inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the tree. <br/></td></tr>
<tr class="separator:adbf3e82fcef7ec85b4338e4b0f317b8d inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c43f98b99ad30b3ac6376e05af049db inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#a8c43f98b99ad30b3ac6376e05af049db">insert</a> (<a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#ae3131f31b2cbbfd725105ae9ca8c99e6">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:a8c43f98b99ad30b3ac6376e05af049db inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a8c43f98b99ad30b3ac6376e05af049db">More...</a><br/></td></tr>
<tr class="separator:a8c43f98b99ad30b3ac6376e05af049db inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31c4fbc7ce6d68b5bf5735322fd2e2f5 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:a31c4fbc7ce6d68b5bf5735322fd2e2f5 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#a31c4fbc7ce6d68b5bf5735322fd2e2f5">insert</a> (<a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#ae3131f31b2cbbfd725105ae9ca8c99e6">value_type</a> &amp;val, Func f)</td></tr>
<tr class="memdesc:a31c4fbc7ce6d68b5bf5735322fd2e2f5 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a31c4fbc7ce6d68b5bf5735322fd2e2f5">More...</a><br/></td></tr>
<tr class="separator:a31c4fbc7ce6d68b5bf5735322fd2e2f5 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac375c93b25a91b2870720d46b168110a inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:ac375c93b25a91b2870720d46b168110a inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#ac375c93b25a91b2870720d46b168110a">ensure</a> (<a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#ae3131f31b2cbbfd725105ae9ca8c99e6">value_type</a> &amp;val, Func func)</td></tr>
<tr class="memdesc:ac375c93b25a91b2870720d46b168110a inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that the <code>val</code> exists in the tree.  <a href="#ac375c93b25a91b2870720d46b168110a">More...</a><br/></td></tr>
<tr class="separator:ac375c93b25a91b2870720d46b168110a inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2a6c46b4b6d495c45d5a738adaf2807 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#ac2a6c46b4b6d495c45d5a738adaf2807">unlink</a> (<a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#ae3131f31b2cbbfd725105ae9ca8c99e6">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:ac2a6c46b4b6d495c45d5a738adaf2807 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlinks the item <code>val</code> from the tree.  <a href="#ac2a6c46b4b6d495c45d5a738adaf2807">More...</a><br/></td></tr>
<tr class="separator:ac2a6c46b4b6d495c45d5a738adaf2807 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7d61dfbf2bb2eaec910dfe72d2971ad inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:aa7d61dfbf2bb2eaec910dfe72d2971ad inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#aa7d61dfbf2bb2eaec910dfe72d2971ad">erase</a> (const Q &amp;val)</td></tr>
<tr class="memdesc:aa7d61dfbf2bb2eaec910dfe72d2971ad inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the tree.  <a href="#aa7d61dfbf2bb2eaec910dfe72d2971ad">More...</a><br/></td></tr>
<tr class="separator:aa7d61dfbf2bb2eaec910dfe72d2971ad inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefec225f967f5a69b73caf7884b83778 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less &gt; </td></tr>
<tr class="memitem:aefec225f967f5a69b73caf7884b83778 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#aefec225f967f5a69b73caf7884b83778">erase_with</a> (const Q &amp;val, Less pred)</td></tr>
<tr class="memdesc:aefec225f967f5a69b73caf7884b83778 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the item from the tree with comparing functor <code>pred</code>.  <a href="#aefec225f967f5a69b73caf7884b83778">More...</a><br/></td></tr>
<tr class="separator:aefec225f967f5a69b73caf7884b83778 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a788887b6b2ff39a708045de9e0eee548 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:a788887b6b2ff39a708045de9e0eee548 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#a788887b6b2ff39a708045de9e0eee548">erase</a> (Q const &amp;val, Func f)</td></tr>
<tr class="memdesc:a788887b6b2ff39a708045de9e0eee548 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the tree.  <a href="#a788887b6b2ff39a708045de9e0eee548">More...</a><br/></td></tr>
<tr class="separator:a788887b6b2ff39a708045de9e0eee548 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55f932bb7bc45e8565968d97d7f77444 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:a55f932bb7bc45e8565968d97d7f77444 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#a55f932bb7bc45e8565968d97d7f77444">erase_with</a> (Q const &amp;val, Less pred, Func f)</td></tr>
<tr class="memdesc:a55f932bb7bc45e8565968d97d7f77444 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the item from the tree with comparing functor <code>pred</code>.  <a href="#a55f932bb7bc45e8565968d97d7f77444">More...</a><br/></td></tr>
<tr class="separator:a55f932bb7bc45e8565968d97d7f77444 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25558c35ddcba60e6137be2d00bdbfe5 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#ae3131f31b2cbbfd725105ae9ca8c99e6">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#a25558c35ddcba60e6137be2d00bdbfe5">extract_min</a> ()</td></tr>
<tr class="memdesc:a25558c35ddcba60e6137be2d00bdbfe5 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an item with minimal key from the tree.  <a href="#a25558c35ddcba60e6137be2d00bdbfe5">More...</a><br/></td></tr>
<tr class="separator:a25558c35ddcba60e6137be2d00bdbfe5 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bf74c7c3f0da38b6ea59b17df19c55f inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#ae3131f31b2cbbfd725105ae9ca8c99e6">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#a6bf74c7c3f0da38b6ea59b17df19c55f">extract_max</a> ()</td></tr>
<tr class="memdesc:a6bf74c7c3f0da38b6ea59b17df19c55f inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an item with maximal key from the tree.  <a href="#a6bf74c7c3f0da38b6ea59b17df19c55f">More...</a><br/></td></tr>
<tr class="separator:a6bf74c7c3f0da38b6ea59b17df19c55f inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aefaed1082d574605ac737bb0ba5be4 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:a0aefaed1082d574605ac737bb0ba5be4 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#ae3131f31b2cbbfd725105ae9ca8c99e6">value_type</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#a0aefaed1082d574605ac737bb0ba5be4">extract</a> (Q const &amp;val)</td></tr>
<tr class="memdesc:a0aefaed1082d574605ac737bb0ba5be4 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an item from the tree.  <a href="#a0aefaed1082d574605ac737bb0ba5be4">More...</a><br/></td></tr>
<tr class="separator:a0aefaed1082d574605ac737bb0ba5be4 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a936dc6e16246a68a7cd30e4d4c62ef94 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less &gt; </td></tr>
<tr class="memitem:a936dc6e16246a68a7cd30e4d4c62ef94 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#ae3131f31b2cbbfd725105ae9ca8c99e6">value_type</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#a936dc6e16246a68a7cd30e4d4c62ef94">extract_with</a> (Q const &amp;val, Less pred)</td></tr>
<tr class="memdesc:a936dc6e16246a68a7cd30e4d4c62ef94 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an item from the set using <code>pred</code> for searching.  <a href="#a936dc6e16246a68a7cd30e4d4c62ef94">More...</a><br/></td></tr>
<tr class="separator:a936dc6e16246a68a7cd30e4d4c62ef94 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84e21d3bbdb7f2233ad321b2b41d1295 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:a84e21d3bbdb7f2233ad321b2b41d1295 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#a84e21d3bbdb7f2233ad321b2b41d1295">find</a> (Q const &amp;val)</td></tr>
<tr class="memdesc:a84e21d3bbdb7f2233ad321b2b41d1295 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code>.  <a href="#a84e21d3bbdb7f2233ad321b2b41d1295">More...</a><br/></td></tr>
<tr class="separator:a84e21d3bbdb7f2233ad321b2b41d1295 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd3c70d4ded131a0862bfb601b0c619 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less &gt; </td></tr>
<tr class="memitem:a0bd3c70d4ded131a0862bfb601b0c619 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#a0bd3c70d4ded131a0862bfb601b0c619">find_with</a> (Q const &amp;val, Less pred)</td></tr>
<tr class="memdesc:a0bd3c70d4ded131a0862bfb601b0c619 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code> with comparing functor <code>pred</code>.  <a href="#a0bd3c70d4ded131a0862bfb601b0c619">More...</a><br/></td></tr>
<tr class="separator:a0bd3c70d4ded131a0862bfb601b0c619 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bcc4f5a28b44c9446d0c0429be8c6de inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:a0bcc4f5a28b44c9446d0c0429be8c6de inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#a0bcc4f5a28b44c9446d0c0429be8c6de">find</a> (Q &amp;val, Func f)</td></tr>
<tr class="memdesc:a0bcc4f5a28b44c9446d0c0429be8c6de inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code>.  <a href="#a0bcc4f5a28b44c9446d0c0429be8c6de">More...</a><br/></td></tr>
<tr class="separator:a0bcc4f5a28b44c9446d0c0429be8c6de inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b9dcab6efef0ac9d0d59d1ce7991e31 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:a9b9dcab6efef0ac9d0d59d1ce7991e31 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#a9b9dcab6efef0ac9d0d59d1ce7991e31">find_with</a> (Q &amp;val, Less pred, Func f)</td></tr>
<tr class="memdesc:a9b9dcab6efef0ac9d0d59d1ce7991e31 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code> with comparing functor <code>pred</code>.  <a href="#a9b9dcab6efef0ac9d0d59d1ce7991e31">More...</a><br/></td></tr>
<tr class="separator:a9b9dcab6efef0ac9d0d59d1ce7991e31 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba15d4d07fa2e07d29b2ac961aa900cd inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:aba15d4d07fa2e07d29b2ac961aa900cd inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#aba15d4d07fa2e07d29b2ac961aa900cd">find</a> (Q const &amp;val, Func f)</td></tr>
<tr class="memdesc:aba15d4d07fa2e07d29b2ac961aa900cd inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code>.  <a href="#aba15d4d07fa2e07d29b2ac961aa900cd">More...</a><br/></td></tr>
<tr class="separator:aba15d4d07fa2e07d29b2ac961aa900cd inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31fd0c85c66f0d651e951005f8ae8afe inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:a31fd0c85c66f0d651e951005f8ae8afe inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#a31fd0c85c66f0d651e951005f8ae8afe">find_with</a> (Q const &amp;val, Less pred, Func f)</td></tr>
<tr class="memdesc:a31fd0c85c66f0d651e951005f8ae8afe inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code> with comparing functor <code>pred</code>.  <a href="#a31fd0c85c66f0d651e951005f8ae8afe">More...</a><br/></td></tr>
<tr class="separator:a31fd0c85c66f0d651e951005f8ae8afe inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ced6be78ddfa215b9f513841175ee22 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2ced6be78ddfa215b9f513841175ee22"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#a2ced6be78ddfa215b9f513841175ee22">empty</a> () const </td></tr>
<tr class="memdesc:a2ced6be78ddfa215b9f513841175ee22 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the tree is empty. <br/></td></tr>
<tr class="separator:a2ced6be78ddfa215b9f513841175ee22 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c0fe86f1ae1ff30607eecd18f64e258 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#a5c0fe86f1ae1ff30607eecd18f64e258">clear</a> ()</td></tr>
<tr class="memdesc:a5c0fe86f1ae1ff30607eecd18f64e258 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the tree (non-atomic)  <a href="#a5c0fe86f1ae1ff30607eecd18f64e258">More...</a><br/></td></tr>
<tr class="separator:a5c0fe86f1ae1ff30607eecd18f64e258 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5629e17edb6c97a68ab8c874c40c24e inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#af5629e17edb6c97a68ab8c874c40c24e">size</a> () const </td></tr>
<tr class="memdesc:af5629e17edb6c97a68ab8c874c40c24e inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns item count in the tree.  <a href="#af5629e17edb6c97a68ab8c874c40c24e">More...</a><br/></td></tr>
<tr class="separator:af5629e17edb6c97a68ab8c874c40c24e inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7601e7c16ffac7bd2b35c1981fec9e43 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7601e7c16ffac7bd2b35c1981fec9e43"></a>
<a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#ace4cf6d51a59d88758d6d161edbb81be">stat</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#a7601e7c16ffac7bd2b35c1981fec9e43">statistics</a> () const </td></tr>
<tr class="memdesc:a7601e7c16ffac7bd2b35c1981fec9e43 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const reference to internal statistics. <br/></td></tr>
<tr class="separator:a7601e7c16ffac7bd2b35c1981fec9e43 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b4655040fdac3b418980da060179253 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#a9b4655040fdac3b418980da060179253">check_consistency</a> () const </td></tr>
<tr class="memdesc:a9b4655040fdac3b418980da060179253 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks internal consistency (not atomic, not thread-safe)  <a href="#a9b4655040fdac3b418980da060179253">More...</a><br/></td></tr>
<tr class="separator:a9b4655040fdac3b418980da060179253 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_attribs_classcds_1_1intrusive_1_1_ellen_bin_tree"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classcds_1_1intrusive_1_1_ellen_bin_tree')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html">cds::intrusive::EllenBinTree&lt; GC, Key, T, Traits &gt;</a></td></tr>
<tr class="memitem:a2aa7e98673d7e142f3f13b35d64834ba inherit pro_attribs_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2aa7e98673d7e142f3f13b35d64834ba"></a>
<a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#a643a24fcfeb9821e7fce2015d3dc3c15">item_counter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#a2aa7e98673d7e142f3f13b35d64834ba">m_ItemCounter</a></td></tr>
<tr class="memdesc:a2aa7e98673d7e142f3f13b35d64834ba inherit pro_attribs_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">item counter <br/></td></tr>
<tr class="separator:a2aa7e98673d7e142f3f13b35d64834ba inherit pro_attribs_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1208d9558392fbb129b605a1c6a8bdd inherit pro_attribs_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad1208d9558392fbb129b605a1c6a8bdd"></a>
<a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#ace4cf6d51a59d88758d6d161edbb81be">stat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#ad1208d9558392fbb129b605a1c6a8bdd">m_Stat</a></td></tr>
<tr class="memdesc:ad1208d9558392fbb129b605a1c6a8bdd inherit pro_attribs_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal statistics <br/></td></tr>
<tr class="separator:ad1208d9558392fbb129b605a1c6a8bdd inherit pro_attribs_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class GC, typename Key, typename T, class Traits = ellen_bintree::type_traits&gt;<br/>
class cds::container::EllenBinTreeSet&lt; GC, Key, T, Traits &gt;</h3>

<p>Set based on Ellen's et al binary search tree. </p>
<p><a class="anchor" id="cds_container_EllenBinTreeSet"></a> Source:</p>
<ul>
<li>[2010] F.Ellen, P.Fatourou, E.Ruppert, F.van Breugel "Non-blocking Binary Search Tree"</li>
</ul>
<p>EllenBinTreeSet is an unbalanced leaf-oriented binary search tree that implements the <em>set</em> abstract data type. Nodes maintains child pointers but not parent pointers. Every internal node has exactly two children, and all data of type <code>T</code> currently in the tree are stored in the leaves. Internal nodes of the tree are used to direct <code>find</code> operation along the path to the correct leaf. The keys (of <code>Key</code> type) stored in internal nodes may or may not be in the set. <code>Key</code> type is a subset of <code>T</code> type. There should be exactly defined a key extracting functor for converting object of type <code>T</code> to object of type <code>Key</code>.</p>
<p>Due to <code>extract_min</code> and <code>extract_max</code> member functions the <code>EllenBinTreeSet</code> can act as a <em>priority queue</em>. In this case you should provide unique compound key, for example, the priority value plus some uniformly distributed random value.</p>
<dl class="section warning"><dt>Warning</dt><dd>Recall the tree is <b>unbalanced</b>. The complexity of operations is <code>O(log N)</code> for uniformly distributed random keys, but in worst case the complexity is <code>O(N)</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>In the current implementation we do not use helping technique described in original paper. So, the current implementation is near to fine-grained lock-based tree. Helping will be implemented in future release</dd></dl>
<p><b>Template arguments</b> :</p>
<ul>
<li><code>GC</code> - safe memory reclamation (i.e. light-weight garbage collector) type, like <a class="el" href="classcds_1_1gc_1_1_h_p.html" title="Hazard Pointer garbage collector. ">cds::gc::HP</a>, <a class="el" href="classcds_1_1gc_1_1_p_t_b.html" title="Pass-the-Buck garbage collector. ">cds::gc::PTB</a> Note that <a class="el" href="classcds_1_1gc_1_1_h_r_c.html" title="Gidenstam&#39;s garbage collector. ">cds::gc::HRC</a> is not supported.</li>
<li><code>Key</code> - key type, a subset of <code>T</code> </li>
<li><code>T</code> - type to be stored in tree's leaf nodes.</li>
<li><code>Traits</code> - type traits. See <a class="el" href="structcds_1_1container_1_1ellen__bintree_1_1type__traits.html" title="Type traits for EllenBinTreeSet, EllenBinTreeMap and EllenBinTreePriorityQueue. ">ellen_bintree::type_traits</a> for explanation.</li>
</ul>
<p>It is possible to declare option-based tree with <a class="el" href="structcds_1_1container_1_1ellen__bintree_1_1make__set__traits.html" title="Metafunction converting option list to EllenBinTreeSet traits. ">ellen_bintree::make_set_traits</a> metafunction instead of <code>Traits</code> template argument. Template argument list <code>Options</code> of <a class="el" href="structcds_1_1container_1_1ellen__bintree_1_1make__set__traits.html" title="Metafunction converting option list to EllenBinTreeSet traits. ">ellen_bintree::make_set_traits</a> metafunction are:</p>
<ul>
<li><a class="el" href="namespacecds_1_1container_1_1ellen__bintree.html#a98c93af580558d5513af1b5a7214e4da" title="Typedef for cds::intrusive::ellen_bintree::key_extractor. ">ellen_bintree::key_extractor</a> - key extracting functor, mandatory option. The functor has the following prototype: <div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="classcds_1_1container_1_1_ellen_bin_tree_set.html#af45a1099459b7e7f92873a37c7a821c8">key_extractor</a> {</div>
<div class="line">    <span class="keywordtype">void</span> operator ()( Key&amp; dest, T <span class="keyword">const</span>&amp; src ) ;</div>
<div class="line">};</div>
</div><!-- fragment --> It should initialize <code>dest</code> key from <code>src</code> data. The functor is used to initialize internal nodes.</li>
<li><a class="el" href="structcds_1_1opt_1_1compare.html" title="[type-option] Option setter for key comparing ">opt::compare</a> - key compare functor. No default functor is provided. If the option is not specified, <code>opt::less</code> is used.</li>
<li><a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate ">opt::less</a> - specifies binary predicate used for key compare. At least <code>opt::compare</code> or <code>opt::less</code> should be defined.</li>
<li><a class="el" href="structcds_1_1opt_1_1item__counter.html" title="[type-option] Option setter for item counting ">opt::item_counter</a> - the type of item counting feature. Default is <a class="el" href="classcds_1_1atomicity_1_1empty__item__counter.html">atomicity::empty_item_counter</a> that is no item counting.</li>
<li><a class="el" href="structcds_1_1opt_1_1memory__model.html" title="[type-option] Option setter for C++ memory model ">opt::memory_model</a> - C++ memory ordering model. Can be <a class="el" href="structcds_1_1opt_1_1v_1_1relaxed__ordering.html" title="Relaxed memory ordering model. ">opt::v::relaxed_ordering</a> (relaxed memory model, the default) or <a class="el" href="structcds_1_1opt_1_1v_1_1sequential__consistent.html" title="Sequential consistent memory ordering model. ">opt::v::sequential_consistent</a> (sequentially consisnent memory model).</li>
<li><a class="el" href="structcds_1_1opt_1_1allocator.html" title="[type-option] Option setter for an allocator ">opt::allocator</a> - the allocator used for <a class="el" href="structcds_1_1container_1_1ellen__bintree_1_1node.html">leaf nodes</a> which contains data. Default is <a class="el" href="user__setup_2allocator_8h.html#ad5fb7e3cbe8cf24295f0ea3c165a2d82">CDS_DEFAULT_ALLOCATOR</a>.</li>
<li><a class="el" href="structcds_1_1opt_1_1node__allocator.html" title="[type-option] Option setter for node allocator ">opt::node_allocator</a> - the allocator used for internal nodes. Default is <a class="el" href="user__setup_2allocator_8h.html#ad5fb7e3cbe8cf24295f0ea3c165a2d82">CDS_DEFAULT_ALLOCATOR</a>.</li>
<li><a class="el" href="namespacecds_1_1container_1_1ellen__bintree.html#abf67b3b7bf47458b02ec081665adec0c" title="Typedef for cds::intrusive::ellen_bintree::update_desc_allocator. ">ellen_bintree::update_desc_allocator</a> - an allocator of <a class="el" href="namespacecds_1_1container_1_1ellen__bintree.html#ab6afc9f1cee19f542868b7cb3541400f">update descriptors</a>, default is <a class="el" href="user__setup_2allocator_8h.html#ad5fb7e3cbe8cf24295f0ea3c165a2d82">CDS_DEFAULT_ALLOCATOR</a>. Note that update descriptor is helping data structure with short lifetime and it is good candidate for pooling. The number of simultaneously existing descriptors is a relatively small number limited the number of threads working with the tree and GC buffer size. Therefore, a bounded lock-free container like <code><a class="el" href="classcds_1_1container_1_1_vyukov_m_p_m_c_cycle_queue.html" title="Vyukov&#39;s MPMC bounded queue. ">cds::container::VyukovMPMCCycleQueue</a></code> is good choice for the free-list of update descriptors, see <a class="el" href="classcds_1_1memory_1_1vyukov__queue__pool.html" title="Free-list based on bounded lock-free queue cds::intrusive::VyukovMPMCCycleQueue. ">cds::memory::vyukov_queue_pool</a> free-list implementation. Also notice that size of update descriptor is not dependent on the type of data stored in the tree so single free-list object can be used for several EllenBinTree-based object.</li>
<li><a class="el" href="structcds_1_1opt_1_1stat.html" title="[type-option] Generic option setter for statisitcs ">opt::stat</a> - internal statistics. Available types: <a class="el" href="namespacecds_1_1container_1_1ellen__bintree.html#a26d24a3f54d0d1f97ddccfa2bb2d95a8" title="Typedef for cds::intrusive::ellen_bintree::stat. ">ellen_bintree::stat</a>, <a class="el" href="namespacecds_1_1container_1_1ellen__bintree.html#a995a1808963654d80b3175a55ffdfe9a" title="Typedef for cds::intrusive::ellen_bintree::empty_stat. ">ellen_bintree::empty_stat</a> (the default)</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Do not include <code>&lt;cds/container/ellen_bintree_set_impl.h&gt;</code> header file directly. There are header file for each GC type:<ul>
<li><code>&lt;cds/container/ellen_bintree_set_hp.h&gt;</code> - for Hazard Pointer GC <a class="el" href="classcds_1_1gc_1_1_h_p.html" title="Hazard Pointer garbage collector. ">cds::gc::HP</a></li>
<li><code>&lt;cds/container/ellen_bintree_set_ptb.h&gt;</code> - for Pass-the-Buck GC <a class="el" href="classcds_1_1gc_1_1_p_t_b.html" title="Pass-the-Buck garbage collector. ">cds::gc::PTB</a></li>
<li><code>&lt;cds/container/ellen_bintree_set_rcu.h&gt;</code> - for RCU GC (see <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#cds_container_EllenBinTreeSet_rcu">RCU-based EllenBinTreeSet</a>)</li>
</ul>
</dd></dl>
<p><a class="anchor" id="cds_container_EllenBinTreeSet_less"></a><b>Predicate requirements</b></p>
<p><a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate ">opt::less</a>, <a class="el" href="structcds_1_1opt_1_1compare.html" title="[type-option] Option setter for key comparing ">opt::compare</a> and other predicates using with member fuctions should accept at least parameters of type <code>T</code> and <code>Key</code> in any combination. For example, for <code>Foo</code> struct with <code>std::string</code> key field the appropiate <code>less</code> functor is: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Foo</div>
<div class="line">{</div>
<div class="line">    std::string m_strKey ;</div>
<div class="line">    ...</div>
<div class="line">} ;</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>less {</div>
<div class="line">    <span class="keywordtype">bool</span> operator()( Foo <span class="keyword">const</span>&amp; v1, Foo <span class="keyword">const</span>&amp; v2 )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{ <span class="keywordflow">return</span> v1.m_strKey &lt; v2.m_strKey ; }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> operator()( Foo <span class="keyword">const</span>&amp; v, std::string <span class="keyword">const</span>&amp; s )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{ <span class="keywordflow">return</span> v.m_strKey &lt; s ; }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> operator()( std::string <span class="keyword">const</span>&amp; s, Foo <span class="keyword">const</span>&amp; v )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{ <span class="keywordflow">return</span> s &lt; v.m_strKey ; }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Support comparing std::string and char const *</span></div>
<div class="line">    <span class="keywordtype">bool</span> operator()( std::string <span class="keyword">const</span>&amp; s, <span class="keywordtype">char</span> <span class="keyword">const</span> * p )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{ <span class="keywordflow">return</span> s.compare(p) &lt; 0 ; }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> operator()( Foo <span class="keyword">const</span>&amp; v, <span class="keywordtype">char</span> <span class="keyword">const</span> * p )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{ <span class="keywordflow">return</span> v.m_strKey.compare(p) &lt; 0 ; }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> operator()( <span class="keywordtype">char</span> <span class="keyword">const</span> * p, std::string <span class="keyword">const</span>&amp; s )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{ <span class="keywordflow">return</span> s.compare(p) &gt; 0; }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> operator()( <span class="keywordtype">char</span> <span class="keyword">const</span> * p, Foo <span class="keyword">const</span>&amp; v )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{ <span class="keywordflow">return</span> v.m_strKey.compare(p) &gt; 0; }</div>
<div class="line">};</div>
</div><!-- fragment --> </div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a0c8d47aa8f13a24b00ff5604ae4c3dbf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html">cds::container::EllenBinTreeSet</a>&lt; GC, Key, T, Traits &gt;::check_consistency </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks internal consistency (not atomic, not thread-safe) </p>
<p>The debugging function to check internal consistency of the tree. </p>

</div>
</div>
<a class="anchor" id="a182706f8c7c47c19da5b0727f71d3d06"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html">cds::container::EllenBinTreeSet</a>&lt; GC, Key, T, Traits &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the set (non-atomic) </p>
<p>The function unlink all items from the tree. The function is not atomic, thus, in multi-threaded environment with parallel insertions this sequence </p>
<div class="fragment"><div class="line">set.clear() ;</div>
<div class="line">assert( set.empty() ) ;</div>
</div><!-- fragment --><p> the assertion could be raised.</p>
<p>For each leaf the <a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#af131f27b7d0df25edc1a58538e067ad4">disposer</a> will be called after unlinking. </p>

</div>
</div>
<a class="anchor" id="abe640538319de2de64353ba15ab5c76c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html">cds::container::EllenBinTreeSet</a>&lt; GC, Key, T, Traits &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts data of type <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html#a316b2a66574539658016af669432d5a3">value_type</a> constructed with <code>std::forward&lt;Args&gt;(args)...</code> </p>
<p>Returns <code>true</code> if inserting successful, <code>false</code> otherwise.</p>
<dl class="section note"><dt>Note</dt><dd>This function is available only for compiler that supports variadic template and move semantics </dd></dl>

</div>
</div>
<a class="anchor" id="a33f548baddc1e809c80adb1617ce7866"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;bool, bool&gt; <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html">cds::container::EllenBinTreeSet</a>&lt; GC, Key, T, Traits &gt;::ensure </td>
          <td>(</td>
          <td class="paramtype">const Q &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensures that the item exists in the set. </p>
<p>The operation performs inserting or changing data with lock-free manner.</p>
<p>If the <code>val</code> key not found in the set, then the new item created from <code>val</code> is inserted into the set. Otherwise, the functor <code>func</code> is called with the item found. The functor <code>Func</code> should be a function with signature: </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> func( <span class="keywordtype">bool</span> bNew, <a class="code" href="classcds_1_1container_1_1_ellen_bin_tree_set.html#a316b2a66574539658016af669432d5a3">value_type</a>&amp; item, <span class="keyword">const</span> Q&amp; val ) ;</div>
</div><!-- fragment --><p> or a functor: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>my_functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <span class="keywordtype">bool</span> bNew, <a class="code" href="classcds_1_1container_1_1_ellen_bin_tree_set.html#a316b2a66574539658016af669432d5a3">value_type</a>&amp; item, <span class="keyword">const</span> Q&amp; val ) ;</div>
<div class="line">};</div>
</div><!-- fragment --><p>with arguments:</p>
<ul>
<li><code>bNew</code> - <code>true</code> if the item has been inserted, <code>false</code> otherwise</li>
<li><code>item</code> - item of the set</li>
<li><code>val</code> - argument <code>key</code> passed into the <code>ensure</code> function</li>
</ul>
<p>The functor may change non-key fields of the <code>item</code>; however, <code>func</code> must guarantee that during changing no any other modifications could be made on this item by concurrent threads.</p>
<p>You may pass <code>func</code> argument by reference using <code>boost::ref</code>.</p>
<p>Returns <code> std::pair&lt;bool, bool&gt; </code> where <code>first</code> is true if operation is successfull, <code>second</code> is true if new item has been added or <code>false</code> if the item with <code>key</code> already is in the set. </p>

</div>
</div>
<a class="anchor" id="a31135b8edf573295cdfab47db77af8d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html">cds::container::EllenBinTreeSet</a>&lt; GC, Key, T, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete <code>key</code> from the set. </p>
<p><a class="anchor" id="cds_nonintrusive_EllenBinTreeSet_erase_val"></a> The item comparator should be able to compare the type <code>value_type</code> and the type <code>Q</code>.</p>
<p>Return <code>true</code> if key is found and deleted, <code>false</code> otherwise </p>

</div>
</div>
<a class="anchor" id="aba00d852182556fc1176f2dfeecef53c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html">cds::container::EllenBinTreeSet</a>&lt; GC, Key, T, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete <code>key</code> from the set. </p>
<p><a class="anchor" id="cds_nonintrusive_EllenBinTreeSet_erase_func"></a> The function searches an item with key <code>key</code>, calls <code>f</code> functor and deletes the item. If <code>key</code> is not found, the functor is not called.</p>
<p>The functor <code>Func</code> interface: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>extractor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()(<a class="code" href="classcds_1_1container_1_1_ellen_bin_tree_set.html#a316b2a66574539658016af669432d5a3">value_type</a> <span class="keyword">const</span>&amp; val) ;</div>
<div class="line">};</div>
</div><!-- fragment --><p> The functor may be passed by reference using <code>boost:ref</code></p>
<p>Since the key of <a class="el" href="classcds_1_1container_1_1_michael_hash_set.html" title="Michael&#39;s hash set. ">MichaelHashSet</a>'s <code>value_type</code> is not explicitly specified, template parameter <code>Q</code> defines the key type searching in the list. The list item comparator should be able to compare the type <code>T</code> of list item and the type <code>Q</code>.</p>
<p>Return <code>true</code> if key is found and deleted, <code>false</code> otherwise </p>

</div>
</div>
<a class="anchor" id="ad165ef7c14badc28f4a8071019396043"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html">cds::container::EllenBinTreeSet</a>&lt; GC, Key, T, Traits &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the set using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html#cds_nonintrusive_EllenBinTreeSet_erase_val">erase(Q const&amp;)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the set. </p>

</div>
</div>
<a class="anchor" id="a7721e0d6f69ebd2b7cfe83b75e37f395"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html">cds::container::EllenBinTreeSet</a>&lt; GC, Key, T, Traits &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the set using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html#cds_nonintrusive_EllenBinTreeSet_erase_func">erase(Q const&amp;, Func)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the set. </p>

</div>
</div>
<a class="anchor" id="a0a9f654c49d9aaa5e00be99a54033d48"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html">cds::container::EllenBinTreeSet</a>&lt; GC, Key, T, Traits &gt;::extract_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html#a316b2a66574539658016af669432d5a3">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>dest</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts an item with maximal key from the set. </p>
<p>If the set is not empty, the function returns <code>true</code>, <code>dest</code> contains the copy of maximum value (assignment operator is called for <code>value_type</code>). If the set is empty, the function returns <code>false</code>, <code>dest</code> is left unchanged.</p>
<dl class="section note"><dt>Note</dt><dd>Due the concurrent nature of the set, the function extracts <em>nearly</em> maximal key. It means that the function gets rightmost leaf of the tree and tries to unlink it. During unlinking, a concurrent thread may insert an item with key great than leftmost item's key. So, the function returns the item with maximum key at the moment of tree traversing. </dd></dl>

</div>
</div>
<a class="anchor" id="ad16225a3950290b06694df10becdb760"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html">cds::container::EllenBinTreeSet</a>&lt; GC, Key, T, Traits &gt;::extract_max </td>
          <td>(</td>
          <td class="paramtype">Q &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts an item with maximal key from the set. </p>
<p>If the set is not empty, the function returns <code>true</code>, <code>f</code> functor is called with value found. If the set is empty, the function returns <code>false</code>, <code>f</code> functor is not called, <code>dest</code> is left unchanged.</p>
<p>The functor <code>Func</code> interface is: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>extract_functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( Q&amp; dest, <a class="code" href="classcds_1_1container_1_1_ellen_bin_tree_set.html#a316b2a66574539658016af669432d5a3">value_type</a>&amp; valueFound ) ;</div>
<div class="line">};</div>
</div><!-- fragment --><p> <code>f</code> can be passed by value or by reference using <code>boost::ref</code> or cds::ref.</p>
<dl class="section note"><dt>Note</dt><dd>Due the concurrent nature of the set, the function extracts <em>nearly</em> maximal key. It means that the function gets rightmost leaf of the tree and tries to unlink it. During unlinking, a concurrent thread may insert an item with key great than leftmost item's key. So, the function returns the item with maximum key at the moment of tree traversing. </dd></dl>

</div>
</div>
<a class="anchor" id="a82348054bfe47e9b7b49c3f7ca235167"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html">cds::container::EllenBinTreeSet</a>&lt; GC, Key, T, Traits &gt;::extract_min </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html#a316b2a66574539658016af669432d5a3">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>dest</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts an item with minimal key from the set. </p>
<p>If the set is not empty, the function returns <code>true</code>, <code>dest</code> contains the copy of minimum value (assignment operator is called for <code>value_type</code>). If the set is empty, the function returns <code>false</code>, <code>dest</code> is left unchanged.</p>
<dl class="section note"><dt>Note</dt><dd>Due the concurrent nature of the set, the function extracts <em>nearly</em> minimum key. It means that the function gets leftmost leaf of the tree and tries to unlink it. During unlinking, a concurrent thread may insert an item with key less than leftmost item's key. So, the function returns the item with minimum key at the moment of tree traversing. </dd></dl>

</div>
</div>
<a class="anchor" id="abdb98987d7c719340caae238ddb66554"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html">cds::container::EllenBinTreeSet</a>&lt; GC, Key, T, Traits &gt;::extract_min </td>
          <td>(</td>
          <td class="paramtype">Q &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts an item with minimal key from the set. </p>
<p>If the set is not empty, the function returns <code>true</code>, <code>f</code> functor is called with value found. If the set is empty, the function returns <code>false</code>, <code>f</code> functor is not called, <code>dest</code> is left unchanged.</p>
<p>The functor <code>Func</code> interface is: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>extract_functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( Q&amp; dest, <a class="code" href="classcds_1_1container_1_1_ellen_bin_tree_set.html#a316b2a66574539658016af669432d5a3">value_type</a>&amp; valueFound ) ;</div>
<div class="line">};</div>
</div><!-- fragment --><p> <code>f</code> can be passed by value or by reference using <code>boost::ref</code> or cds::ref.</p>
<dl class="section note"><dt>Note</dt><dd>Due the concurrent nature of the set, the function extracts <em>nearly</em> minimum key. It means that the function gets leftmost leaf of the tree and tries to unlink it. During unlinking, a concurrent thread may insert an item with key less than leftmost item's key. So, the function returns the item with minimum key at the moment of tree traversing. </dd></dl>

</div>
</div>
<a class="anchor" id="a7ad1b0d393299bd62119e6a0187bb65c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html">cds::container::EllenBinTreeSet</a>&lt; GC, Key, T, Traits &gt;::find </td>
          <td>(</td>
          <td class="paramtype">Q &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the key <code>val</code>. </p>
<p><a class="anchor" id="cds_nonintrusive_EllenBinTreeSet_find_func"></a> The function searches the item with key equal to <code>val</code> and calls the functor <code>f</code> for item found. The interface of <code>Func</code> functor is: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1container_1_1_ellen_bin_tree_set.html#a316b2a66574539658016af669432d5a3">value_type</a>&amp; item, Q&amp; val ) ;</div>
<div class="line">};</div>
</div><!-- fragment --><p> where <code>item</code> is the item found, <code>val</code> is the <code>find</code> function argument.</p>
<p>You may pass <code>f</code> argument by reference using <code>boost::ref</code> or cds::ref.</p>
<p>The functor may change non-key fields of <code>item</code>. Note that the functor is only guarantee that <code>item</code> cannot be disposed during functor is executing. The functor does not serialize simultaneous access to the set's <code>item</code>. If such access is possible you must provide your own synchronization schema on item level to exclude unsafe item modifications.</p>
<p>The <code>val</code> argument is non-const since it can be used as <code>f</code> functor destination i.e., the functor can modify both arguments.</p>
<p>Note the hash functor specified for class <code>Traits</code> template parameter should accept a parameter of type <code>Q</code> that may be not the same as <code>value_type</code>.</p>
<p>The function returns <code>true</code> if <code>val</code> is found, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a6d0828399485ca77dec429898dbdd273"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html">cds::container::EllenBinTreeSet</a>&lt; GC, Key, T, Traits &gt;::find </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the key <code>val</code>. </p>
<p><a class="anchor" id="cds_nonintrusive_EllenBinTreeSet_find_cfunc"></a> The function searches the item with key equal to <code>val</code> and calls the functor <code>f</code> for item found. The interface of <code>Func</code> functor is: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1container_1_1_ellen_bin_tree_set.html#a316b2a66574539658016af669432d5a3">value_type</a>&amp; item, Q <span class="keyword">const</span>&amp; val ) ;</div>
<div class="line">};</div>
</div><!-- fragment --><p> where <code>item</code> is the item found, <code>val</code> is the <code>find</code> function argument.</p>
<p>You may pass <code>f</code> argument by reference using <code>boost::ref</code> or cds::ref.</p>
<p>The functor may change non-key fields of <code>item</code>. Note that the functor is only guarantee that <code>item</code> cannot be disposed during functor is executing. The functor does not serialize simultaneous access to the set's <code>item</code>. If such access is possible you must provide your own synchronization schema on item level to exclude unsafe item modifications.</p>
<p>Note the hash functor specified for class <code>Traits</code> template parameter should accept a parameter of type <code>Q</code> that may be not the same as <code>value_type</code>.</p>
<p>The function returns <code>true</code> if <code>val</code> is found, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a7c211116cbfa7cd894fe7ff88525f75b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html">cds::container::EllenBinTreeSet</a>&lt; GC, Key, T, Traits &gt;::find </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the key <code>val</code>. </p>
<p><a class="anchor" id="cds_nonintrusive_EllenBinTreeSet_find_val"></a> The function searches the item with key equal to <code>val</code> and returns <code>true</code> if it is found, and <code>false</code> otherwise.</p>
<p>Note the hash functor specified for class <code>Traits</code> template parameter should accept a parameter of type <code>Q</code> that may be not the same as <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html#a316b2a66574539658016af669432d5a3">value_type</a>. </p>

</div>
</div>
<a class="anchor" id="a712236f343bc55e40dceee73875e0308"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html">cds::container::EllenBinTreeSet</a>&lt; GC, Key, T, Traits &gt;::find_with </td>
          <td>(</td>
          <td class="paramtype">Q &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the key <code>val</code> using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html#cds_nonintrusive_EllenBinTreeSet_find_func">find(Q&amp;, Func)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the set. </p>

</div>
</div>
<a class="anchor" id="a8503f12ff72fe5739fe5a8cf94c39393"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html">cds::container::EllenBinTreeSet</a>&lt; GC, Key, T, Traits &gt;::find_with </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the key <code>val</code> using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html#cds_nonintrusive_EllenBinTreeSet_find_cfunc">find(Q const&amp;, Func)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the set. </p>

</div>
</div>
<a class="anchor" id="a30875b982377a268abcff448819c4ef3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html">cds::container::EllenBinTreeSet</a>&lt; GC, Key, T, Traits &gt;::find_with </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the key <code>val</code> using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html#cds_nonintrusive_EllenBinTreeSet_find_val">find(Q const&amp;)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the set. </p>

</div>
</div>
<a class="anchor" id="a1300b9b363b7bc86e1d7c5018bb7a064"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html">cds::container::EllenBinTreeSet</a>&lt; GC, Key, T, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node. </p>
<p>The function creates a node with copy of <code>val</code> value and then inserts the node created into the set.</p>
<p>The type <code>Q</code> should contain at least the complete key for the node. The object of <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html#a316b2a66574539658016af669432d5a3">value_type</a> should be constructible from a value of type <code>Q</code>. In trivial case, <code>Q</code> is equal to <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html#a316b2a66574539658016af669432d5a3">value_type</a>.</p>
<p>Returns <code>true</code> if <code>val</code> is inserted into the set, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="aa8a30bcb9a89999dfaff7c0be67c0488"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html">cds::container::EllenBinTreeSet</a>&lt; GC, Key, T, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node. </p>
<p>The function allows to split creating of new item into two part:</p>
<ul>
<li>create item with key only</li>
<li>insert new item into the set</li>
<li>if inserting is success, calls <code>f</code> functor to initialize value-fields of <code>val</code>.</li>
</ul>
<p>The functor signature is: </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> func( <a class="code" href="classcds_1_1container_1_1_ellen_bin_tree_set.html#a316b2a66574539658016af669432d5a3">value_type</a>&amp; val ) ;</div>
</div><!-- fragment --><p> where <code>val</code> is the item inserted. User-defined functor <code>f</code> should guarantee that during changing <code>val</code> no any other changes could be made on this set's item by concurrent threads. The user-defined functor is called only if the inserting is success. It may be passed by reference using <code>boost::ref</code> </p>

</div>
</div>
<a class="anchor" id="acf3a6e00a7ef226568e97f3d3653870d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html">cds::container::EllenBinTreeSet</a>&lt; GC, Key, T, Traits &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns item count in the set. </p>
<p>Only leaf nodes containing user data are counted.</p>
<p>The value returned depends on item counter type provided by <code>Traits</code> template parameter. If it is <a class="el" href="classcds_1_1atomicity_1_1empty__item__counter.html" title="Empty item counter. ">atomicity::empty_item_counter</a> this function always returns 0. Therefore, the function is not suitable for checking the tree emptiness, use <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html#af3006cfb9220b46b857958e346cbaca3">empty</a> member function for this purpose. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>cds/container/ellen_bintree_set_impl.h</li>
</ul>
</div><!-- contents -->
		<hr/>
		<div align="right">
			<b>cds</b> <b>1.5.0</b> 
			Developed by <i>Maxim Khiszinsky aka khizmax</i> 2007 - 2012
			<br/>
			<i>Autogenerated Sat Dec 28 2013 15:04:02 by Doxygen 1.8.5</i>
		</div>
	</BODY>
</HTML>
