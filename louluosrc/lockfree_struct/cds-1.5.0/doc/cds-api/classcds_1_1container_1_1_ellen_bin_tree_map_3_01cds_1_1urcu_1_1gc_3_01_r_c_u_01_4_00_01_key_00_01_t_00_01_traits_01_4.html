<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>cds: cds::container::EllenBinTreeMap&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">cds
   &#160;<span id="projectnumber">1.5.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecds.html">cds</a></li><li class="navelem"><a class="el" href="namespacecds_1_1container.html">container</a></li><li class="navelem"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html">EllenBinTreeMap< cds::urcu::gc< RCU >, Key, T, Traits ></a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">cds::container::EllenBinTreeMap&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__cds__nonintrusive__map.html">Map</a> &#124; <a class="el" href="group__cds__nonintrusive__tree.html">Tree</a> &#124; <a class="el" href="group__cds__nonintrusive__priority__queue.html">Priority queue</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Map based on Ellen's et al binary search tree (RCU specialization)  
 <a href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#details">More...</a></p>

<p><code>#include &lt;cds/container/ellen_bintree_map_rcu.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cds::container::EllenBinTreeMap&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.png" usemap="#cds::container::EllenBinTreeMap&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;_map" alt=""/>
  <map id="cds::container::EllenBinTreeMap&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;_map" name="cds::container::EllenBinTreeMap&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;_map">
<area href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html" title="Ellen&#39;s et al binary search tree (RCU specialization) " alt="cds::intrusive::EllenBinTree&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;" shape="rect" coords="0,0,426,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a6690fb13610766a02ac031f77c196b23"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6690fb13610766a02ac031f77c196b23"></a>
typedef cds::urcu::gc&lt; RCU &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a6690fb13610766a02ac031f77c196b23">gc</a></td></tr>
<tr class="memdesc:a6690fb13610766a02ac031f77c196b23"><td class="mdescLeft">&#160;</td><td class="mdescRight">RCU Garbage collector. <br/></td></tr>
<tr class="separator:a6690fb13610766a02ac031f77c196b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acab0193fda53d0ae8de2733329057eda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acab0193fda53d0ae8de2733329057eda"></a>
typedef Key&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#acab0193fda53d0ae8de2733329057eda">key_type</a></td></tr>
<tr class="memdesc:acab0193fda53d0ae8de2733329057eda"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of a key stored in the map <br/></td></tr>
<tr class="separator:acab0193fda53d0ae8de2733329057eda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1faa61720dd1c60f5a27bcd5fcc5fe06"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1faa61720dd1c60f5a27bcd5fcc5fe06"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a1faa61720dd1c60f5a27bcd5fcc5fe06">mapped_type</a></td></tr>
<tr class="memdesc:a1faa61720dd1c60f5a27bcd5fcc5fe06"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of value stored in the map <br/></td></tr>
<tr class="separator:a1faa61720dd1c60f5a27bcd5fcc5fe06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3baf873ae293f63b5b5ff6431515e68e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3baf873ae293f63b5b5ff6431515e68e"></a>
typedef std::pair&lt; <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#acab0193fda53d0ae8de2733329057eda">key_type</a> <br class="typebreak"/>
const, <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a1faa61720dd1c60f5a27bcd5fcc5fe06">mapped_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a3baf873ae293f63b5b5ff6431515e68e">value_type</a></td></tr>
<tr class="memdesc:a3baf873ae293f63b5b5ff6431515e68e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key-value pair stored in leaf node of the mp. <br/></td></tr>
<tr class="separator:a3baf873ae293f63b5b5ff6431515e68e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdafe61627efefb838d831b2948eaeae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acdafe61627efefb838d831b2948eaeae"></a>
typedef Traits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#acdafe61627efefb838d831b2948eaeae">options</a></td></tr>
<tr class="memdesc:acdafe61627efefb838d831b2948eaeae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits template parameter. <br/></td></tr>
<tr class="separator:acdafe61627efefb838d831b2948eaeae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addef800784dfa2cf89c4dddfaf9c0382"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="addef800784dfa2cf89c4dddfaf9c0382"></a>
typedef implementation_defined&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#addef800784dfa2cf89c4dddfaf9c0382">key_comparator</a></td></tr>
<tr class="memdesc:addef800784dfa2cf89c4dddfaf9c0382"><td class="mdescLeft">&#160;</td><td class="mdescRight">key compare functor based on <a class="el" href="structcds_1_1opt_1_1compare.html" title="[type-option] Option setter for key comparing ">opt::compare</a> and <a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate ">opt::less</a> option setter. <br/></td></tr>
<tr class="separator:addef800784dfa2cf89c4dddfaf9c0382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9737f69f9d0758740d756754bb77bcce"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9737f69f9d0758740d756754bb77bcce"></a>
typedef base_class::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a9737f69f9d0758740d756754bb77bcce">item_counter</a></td></tr>
<tr class="memdesc:a9737f69f9d0758740d756754bb77bcce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counting policy used. <br/></td></tr>
<tr class="separator:a9737f69f9d0758740d756754bb77bcce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2dc6859068bd7fe8df69eac06b61ff2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac2dc6859068bd7fe8df69eac06b61ff2"></a>
typedef base_class::memory_model&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ac2dc6859068bd7fe8df69eac06b61ff2">memory_model</a></td></tr>
<tr class="memdesc:ac2dc6859068bd7fe8df69eac06b61ff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory ordering. See <a class="el" href="structcds_1_1opt_1_1memory__model.html" title="[type-option] Option setter for C++ memory model ">cds::opt::memory_model</a> option. <br/></td></tr>
<tr class="separator:ac2dc6859068bd7fe8df69eac06b61ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a194fe5abd28224cd12aba98a57a9d368"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a194fe5abd28224cd12aba98a57a9d368"></a>
typedef base_class::node_allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a194fe5abd28224cd12aba98a57a9d368">node_allocator_type</a></td></tr>
<tr class="memdesc:a194fe5abd28224cd12aba98a57a9d368"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocator for maintaining internal node <br/></td></tr>
<tr class="separator:a194fe5abd28224cd12aba98a57a9d368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a848b6a5a9e54bc26e634635b14a864a2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a848b6a5a9e54bc26e634635b14a864a2"></a>
typedef base_class::stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a848b6a5a9e54bc26e634635b14a864a2">stat</a></td></tr>
<tr class="memdesc:a848b6a5a9e54bc26e634635b14a864a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal statistics type <br/></td></tr>
<tr class="separator:a848b6a5a9e54bc26e634635b14a864a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6c3b7863bc65390e76a3a8eb7f348c3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad6c3b7863bc65390e76a3a8eb7f348c3"></a>
typedef <br class="typebreak"/>
base_class::rcu_check_deadlock&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ad6c3b7863bc65390e76a3a8eb7f348c3">rcu_check_deadlock</a></td></tr>
<tr class="memdesc:ad6c3b7863bc65390e76a3a8eb7f348c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deadlock checking policy. <br/></td></tr>
<tr class="separator:ad6c3b7863bc65390e76a3a8eb7f348c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d6578a2c7df874449e5df1941f196c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d6578a2c7df874449e5df1941f196c0"></a>
typedef options::copy_policy&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a1d6578a2c7df874449e5df1941f196c0">copy_policy</a></td></tr>
<tr class="memdesc:a1d6578a2c7df874449e5df1941f196c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">key copy policy <br/></td></tr>
<tr class="separator:a1d6578a2c7df874449e5df1941f196c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c155ea0b55c2fe4b39c90006fa7e2d8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c155ea0b55c2fe4b39c90006fa7e2d8"></a>
typedef options::allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a3c155ea0b55c2fe4b39c90006fa7e2d8">allocator_type</a></td></tr>
<tr class="memdesc:a3c155ea0b55c2fe4b39c90006fa7e2d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator for leaf nodes. <br/></td></tr>
<tr class="separator:a3c155ea0b55c2fe4b39c90006fa7e2d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e559ec05140ebc2fbb759613e779882"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4e559ec05140ebc2fbb759613e779882"></a>
typedef base_class::node_allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a4e559ec05140ebc2fbb759613e779882">node_allocator</a></td></tr>
<tr class="memdesc:a4e559ec05140ebc2fbb759613e779882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal node allocator. <br/></td></tr>
<tr class="separator:a4e559ec05140ebc2fbb759613e779882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a513395248b2b46d5f2e0c0748ae6633d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a513395248b2b46d5f2e0c0748ae6633d"></a>
typedef <br class="typebreak"/>
base_class::update_desc_allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a513395248b2b46d5f2e0c0748ae6633d">update_desc_allocator</a></td></tr>
<tr class="memdesc:a513395248b2b46d5f2e0c0748ae6633d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update descriptor allocator. <br/></td></tr>
<tr class="separator:a513395248b2b46d5f2e0c0748ae6633d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html">cds::intrusive::EllenBinTree&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;</a></td></tr>
<tr class="memitem:a1c077a01c42f58242a9a8534e503ca0e inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c077a01c42f58242a9a8534e503ca0e"></a>
typedef cds::urcu::gc&lt; RCU &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a1c077a01c42f58242a9a8534e503ca0e">gc</a></td></tr>
<tr class="memdesc:a1c077a01c42f58242a9a8534e503ca0e inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">RCU Garbage collector. <br/></td></tr>
<tr class="separator:a1c077a01c42f58242a9a8534e503ca0e inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c6b62e5002f389473533d0d8e185da inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af5c6b62e5002f389473533d0d8e185da"></a>
typedef Key&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#af5c6b62e5002f389473533d0d8e185da">key_type</a></td></tr>
<tr class="memdesc:af5c6b62e5002f389473533d0d8e185da inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of a key stored in internal nodes; key is a part of <code>value_type</code> <br/></td></tr>
<tr class="separator:af5c6b62e5002f389473533d0d8e185da inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add56a738dd647d7d4afee42ba853cd49 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add56a738dd647d7d4afee42ba853cd49"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#add56a738dd647d7d4afee42ba853cd49">value_type</a></td></tr>
<tr class="memdesc:add56a738dd647d7d4afee42ba853cd49 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of value stored in the binary tree <br/></td></tr>
<tr class="separator:add56a738dd647d7d4afee42ba853cd49 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79638e8405e79af1e03575530920d8f6 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a79638e8405e79af1e03575530920d8f6"></a>
typedef Traits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a79638e8405e79af1e03575530920d8f6">options</a></td></tr>
<tr class="memdesc:a79638e8405e79af1e03575530920d8f6 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits template parameter. <br/></td></tr>
<tr class="separator:a79638e8405e79af1e03575530920d8f6 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b2ef016fe17338a78c96ea164b66598 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b2ef016fe17338a78c96ea164b66598"></a>
typedef options::hook&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a3b2ef016fe17338a78c96ea164b66598">hook</a></td></tr>
<tr class="memdesc:a3b2ef016fe17338a78c96ea164b66598 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">hook type <br/></td></tr>
<tr class="separator:a3b2ef016fe17338a78c96ea164b66598 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2a32ff430f6656f931a19abc62559f0 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac2a32ff430f6656f931a19abc62559f0"></a>
typedef hook::node_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ac2a32ff430f6656f931a19abc62559f0">node_type</a></td></tr>
<tr class="memdesc:ac2a32ff430f6656f931a19abc62559f0 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">node type <br/></td></tr>
<tr class="separator:ac2a32ff430f6656f931a19abc62559f0 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4c742b3e71e3e6f8c18088a94be9e8 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc4c742b3e71e3e6f8c18088a94be9e8"></a>
typedef options::disposer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#abc4c742b3e71e3e6f8c18088a94be9e8">disposer</a></td></tr>
<tr class="memdesc:abc4c742b3e71e3e6f8c18088a94be9e8 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">leaf node disposer <br/></td></tr>
<tr class="separator:abc4c742b3e71e3e6f8c18088a94be9e8 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcbe0005ae2be7aba4142ad27517220e inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adcbe0005ae2be7aba4142ad27517220e"></a>
typedef implementation_defined&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#adcbe0005ae2be7aba4142ad27517220e">key_comparator</a></td></tr>
<tr class="memdesc:adcbe0005ae2be7aba4142ad27517220e inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">key compare functor based on <a class="el" href="structcds_1_1opt_1_1compare.html" title="[type-option] Option setter for key comparing ">opt::compare</a> and <a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate ">opt::less</a> option setter. <br/></td></tr>
<tr class="separator:adcbe0005ae2be7aba4142ad27517220e inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a731dd06317b60f47d72a6589e9aad44b inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a731dd06317b60f47d72a6589e9aad44b"></a>
typedef <a class="el" href="structcds_1_1intrusive_1_1get__node__traits.html">get_node_traits</a><br class="typebreak"/>
&lt; <a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#add56a738dd647d7d4afee42ba853cd49">value_type</a>, <a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ac2a32ff430f6656f931a19abc62559f0">node_type</a>, <a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a3b2ef016fe17338a78c96ea164b66598">hook</a> &gt;<br class="typebreak"/>
::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a731dd06317b60f47d72a6589e9aad44b">node_traits</a></td></tr>
<tr class="memdesc:a731dd06317b60f47d72a6589e9aad44b inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node traits. <br/></td></tr>
<tr class="separator:a731dd06317b60f47d72a6589e9aad44b inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf5e22a713d77a11d5ae1bf80377b4d9 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf5e22a713d77a11d5ae1bf80377b4d9"></a>
typedef options::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#abf5e22a713d77a11d5ae1bf80377b4d9">item_counter</a></td></tr>
<tr class="memdesc:abf5e22a713d77a11d5ae1bf80377b4d9 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counting policy used. <br/></td></tr>
<tr class="separator:abf5e22a713d77a11d5ae1bf80377b4d9 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61d66cd9eeed39412078763b0dc362c4 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a61d66cd9eeed39412078763b0dc362c4"></a>
typedef options::memory_model&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a61d66cd9eeed39412078763b0dc362c4">memory_model</a></td></tr>
<tr class="memdesc:a61d66cd9eeed39412078763b0dc362c4 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory ordering. See <a class="el" href="structcds_1_1opt_1_1memory__model.html" title="[type-option] Option setter for C++ memory model ">cds::opt::memory_model</a> option. <br/></td></tr>
<tr class="separator:a61d66cd9eeed39412078763b0dc362c4 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1aa9f8188ea6d8a45aaf8d22a712173 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1aa9f8188ea6d8a45aaf8d22a712173"></a>
typedef options::stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#af1aa9f8188ea6d8a45aaf8d22a712173">stat</a></td></tr>
<tr class="memdesc:af1aa9f8188ea6d8a45aaf8d22a712173 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal statistics type <br/></td></tr>
<tr class="separator:af1aa9f8188ea6d8a45aaf8d22a712173 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a689e3dbc45e816fe171a995c46b1a296 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a689e3dbc45e816fe171a995c46b1a296"></a>
typedef options::rcu_check_deadlock&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a689e3dbc45e816fe171a995c46b1a296">rcu_check_deadlock</a></td></tr>
<tr class="memdesc:a689e3dbc45e816fe171a995c46b1a296 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deadlock checking policy. <br/></td></tr>
<tr class="separator:a689e3dbc45e816fe171a995c46b1a296 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a679e8232c324483ed90fcb4ae3c7edb5 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a679e8232c324483ed90fcb4ae3c7edb5"></a>
typedef options::key_extractor&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a679e8232c324483ed90fcb4ae3c7edb5">key_extractor</a></td></tr>
<tr class="memdesc:a679e8232c324483ed90fcb4ae3c7edb5 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">key extracting functor <br/></td></tr>
<tr class="separator:a679e8232c324483ed90fcb4ae3c7edb5 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23d555320e46b05bfabea6db60e0fa62 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a23d555320e46b05bfabea6db60e0fa62"></a>
typedef options::node_allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a23d555320e46b05bfabea6db60e0fa62">node_allocator</a></td></tr>
<tr class="memdesc:a23d555320e46b05bfabea6db60e0fa62 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal node allocator. <br/></td></tr>
<tr class="separator:a23d555320e46b05bfabea6db60e0fa62 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a779c248a32902476f7860e94910efaef inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a779c248a32902476f7860e94910efaef"></a>
typedef <br class="typebreak"/>
options::update_desc_allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a779c248a32902476f7860e94910efaef">update_desc_allocator</a></td></tr>
<tr class="memdesc:a779c248a32902476f7860e94910efaef inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update descriptor allocator. <br/></td></tr>
<tr class="separator:a779c248a32902476f7860e94910efaef inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a10e6c19445517327f39ad1562d9f8a1b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a10e6c19445517327f39ad1562d9f8a1b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a10e6c19445517327f39ad1562d9f8a1b">EllenBinTreeMap</a> ()</td></tr>
<tr class="memdesc:a10e6c19445517327f39ad1562d9f8a1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br/></td></tr>
<tr class="separator:a10e6c19445517327f39ad1562d9f8a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af23254cd3d933989991e37a8c94c8382"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af23254cd3d933989991e37a8c94c8382"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#af23254cd3d933989991e37a8c94c8382">~EllenBinTreeMap</a> ()</td></tr>
<tr class="memdesc:af23254cd3d933989991e37a8c94c8382"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the map. <br/></td></tr>
<tr class="separator:af23254cd3d933989991e37a8c94c8382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbac8c1563935506629b0193064176f9"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:afbac8c1563935506629b0193064176f9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#afbac8c1563935506629b0193064176f9">insert</a> (K const &amp;key)</td></tr>
<tr class="memdesc:afbac8c1563935506629b0193064176f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node with key and default value.  <a href="#afbac8c1563935506629b0193064176f9">More...</a><br/></td></tr>
<tr class="separator:afbac8c1563935506629b0193064176f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f5084e9d0dbda621611870e65e25ed0"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V &gt; </td></tr>
<tr class="memitem:a9f5084e9d0dbda621611870e65e25ed0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a9f5084e9d0dbda621611870e65e25ed0">insert</a> (K const &amp;key, V const &amp;val)</td></tr>
<tr class="memdesc:a9f5084e9d0dbda621611870e65e25ed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a9f5084e9d0dbda621611870e65e25ed0">More...</a><br/></td></tr>
<tr class="separator:a9f5084e9d0dbda621611870e65e25ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a299decf525e9a001eb7f6ca5f4274390"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Func &gt; </td></tr>
<tr class="memitem:a299decf525e9a001eb7f6ca5f4274390"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a299decf525e9a001eb7f6ca5f4274390">insert_key</a> (const K &amp;key, Func func)</td></tr>
<tr class="memdesc:a299decf525e9a001eb7f6ca5f4274390"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node and initialize it by a functor.  <a href="#a299decf525e9a001eb7f6ca5f4274390">More...</a><br/></td></tr>
<tr class="separator:a299decf525e9a001eb7f6ca5f4274390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58e53d25d3058462581d14d8134fdca1"><td class="memTemplParams" colspan="2">template&lt;typename K , typename... Args&gt; </td></tr>
<tr class="memitem:a58e53d25d3058462581d14d8134fdca1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a58e53d25d3058462581d14d8134fdca1">emplace</a> (K &amp;&amp;key, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a58e53d25d3058462581d14d8134fdca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">For key <code>key</code> inserts data of type <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a3baf873ae293f63b5b5ff6431515e68e">value_type</a> constructed with <code>std::forward&lt;Args&gt;(args)...</code>  <a href="#a58e53d25d3058462581d14d8134fdca1">More...</a><br/></td></tr>
<tr class="separator:a58e53d25d3058462581d14d8134fdca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9069f247464eaa2ab5821220a4ad679"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Func &gt; </td></tr>
<tr class="memitem:ab9069f247464eaa2ab5821220a4ad679"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ab9069f247464eaa2ab5821220a4ad679">ensure</a> (K const &amp;key, Func func)</td></tr>
<tr class="memdesc:ab9069f247464eaa2ab5821220a4ad679"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that the <code>key</code> exists in the map.  <a href="#ab9069f247464eaa2ab5821220a4ad679">More...</a><br/></td></tr>
<tr class="separator:ab9069f247464eaa2ab5821220a4ad679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef6901ac037b94518242d4cdb4c03530"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:aef6901ac037b94518242d4cdb4c03530"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#aef6901ac037b94518242d4cdb4c03530">erase</a> (K const &amp;key)</td></tr>
<tr class="memdesc:aef6901ac037b94518242d4cdb4c03530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete <code>key</code> from the map.  <a href="#aef6901ac037b94518242d4cdb4c03530">More...</a><br/></td></tr>
<tr class="separator:aef6901ac037b94518242d4cdb4c03530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a95ba4ead2f0010620ce8821b7a81ca"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less &gt; </td></tr>
<tr class="memitem:a6a95ba4ead2f0010620ce8821b7a81ca"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a6a95ba4ead2f0010620ce8821b7a81ca">erase_with</a> (K const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a6a95ba4ead2f0010620ce8821b7a81ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the map using <code>pred</code> predicate for searching.  <a href="#a6a95ba4ead2f0010620ce8821b7a81ca">More...</a><br/></td></tr>
<tr class="separator:a6a95ba4ead2f0010620ce8821b7a81ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a116b712f8cd1096ae4ff3bc308368c06"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Func &gt; </td></tr>
<tr class="memitem:a116b712f8cd1096ae4ff3bc308368c06"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a116b712f8cd1096ae4ff3bc308368c06">erase</a> (K const &amp;key, Func f)</td></tr>
<tr class="memdesc:a116b712f8cd1096ae4ff3bc308368c06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete <code>key</code> from the map.  <a href="#a116b712f8cd1096ae4ff3bc308368c06">More...</a><br/></td></tr>
<tr class="separator:a116b712f8cd1096ae4ff3bc308368c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b93a7ed5880dacdc5e8f8e8e63e614c"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:a4b93a7ed5880dacdc5e8f8e8e63e614c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a4b93a7ed5880dacdc5e8f8e8e63e614c">erase_with</a> (K const &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:a4b93a7ed5880dacdc5e8f8e8e63e614c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the map using <code>pred</code> predicate for searching.  <a href="#a4b93a7ed5880dacdc5e8f8e8e63e614c">More...</a><br/></td></tr>
<tr class="separator:a4b93a7ed5880dacdc5e8f8e8e63e614c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5da9bbd15dcdf65504574636d4beae0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#aa5da9bbd15dcdf65504574636d4beae0">extract_min</a> (std::pair&lt; <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#acab0193fda53d0ae8de2733329057eda">key_type</a>, <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a1faa61720dd1c60f5a27bcd5fcc5fe06">mapped_type</a> &gt; &amp;dest)</td></tr>
<tr class="memdesc:aa5da9bbd15dcdf65504574636d4beae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an item with minimal key from the map.  <a href="#aa5da9bbd15dcdf65504574636d4beae0">More...</a><br/></td></tr>
<tr class="separator:aa5da9bbd15dcdf65504574636d4beae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64c5c4c3545cd75ac8abf5ab07e96c7d"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:a64c5c4c3545cd75ac8abf5ab07e96c7d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a64c5c4c3545cd75ac8abf5ab07e96c7d">extract_min</a> (Q &amp;dest, Func f)</td></tr>
<tr class="memdesc:a64c5c4c3545cd75ac8abf5ab07e96c7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an item with minimal key from the map.  <a href="#a64c5c4c3545cd75ac8abf5ab07e96c7d">More...</a><br/></td></tr>
<tr class="separator:a64c5c4c3545cd75ac8abf5ab07e96c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab30d6ba1f3d4ebaec9cf0ca1aff42ad7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ab30d6ba1f3d4ebaec9cf0ca1aff42ad7">extract_max</a> (std::pair&lt; <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#acab0193fda53d0ae8de2733329057eda">key_type</a>, <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a1faa61720dd1c60f5a27bcd5fcc5fe06">mapped_type</a> &gt; &amp;dest)</td></tr>
<tr class="memdesc:ab30d6ba1f3d4ebaec9cf0ca1aff42ad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an item with maximal key from the map.  <a href="#ab30d6ba1f3d4ebaec9cf0ca1aff42ad7">More...</a><br/></td></tr>
<tr class="separator:ab30d6ba1f3d4ebaec9cf0ca1aff42ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ae0bf487db2bddcb7e32391cf7a843"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:ac4ae0bf487db2bddcb7e32391cf7a843"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ac4ae0bf487db2bddcb7e32391cf7a843">extract_max</a> (Q &amp;dest, Func f)</td></tr>
<tr class="memdesc:ac4ae0bf487db2bddcb7e32391cf7a843"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an item with maximal key from the map.  <a href="#ac4ae0bf487db2bddcb7e32391cf7a843">More...</a><br/></td></tr>
<tr class="separator:ac4ae0bf487db2bddcb7e32391cf7a843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4625f995111e1a99db7bacd8cb04ae52"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Func &gt; </td></tr>
<tr class="memitem:a4625f995111e1a99db7bacd8cb04ae52"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a4625f995111e1a99db7bacd8cb04ae52">find</a> (K const &amp;key, Func f)</td></tr>
<tr class="memdesc:a4625f995111e1a99db7bacd8cb04ae52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>key</code>.  <a href="#a4625f995111e1a99db7bacd8cb04ae52">More...</a><br/></td></tr>
<tr class="separator:a4625f995111e1a99db7bacd8cb04ae52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38d967a6dfe520c46e2100f96b385d1d"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:a38d967a6dfe520c46e2100f96b385d1d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a38d967a6dfe520c46e2100f96b385d1d">find_with</a> (K const &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:a38d967a6dfe520c46e2100f96b385d1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code> using <code>pred</code> predicate for searching.  <a href="#a38d967a6dfe520c46e2100f96b385d1d">More...</a><br/></td></tr>
<tr class="separator:a38d967a6dfe520c46e2100f96b385d1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97ebcd10766ce469899465887029a0e0"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:a97ebcd10766ce469899465887029a0e0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a97ebcd10766ce469899465887029a0e0">find</a> (K const &amp;key)</td></tr>
<tr class="memdesc:a97ebcd10766ce469899465887029a0e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>key</code>.  <a href="#a97ebcd10766ce469899465887029a0e0">More...</a><br/></td></tr>
<tr class="separator:a97ebcd10766ce469899465887029a0e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e8b53ac7d920b47b17c665972f8715"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less &gt; </td></tr>
<tr class="memitem:a12e8b53ac7d920b47b17c665972f8715"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a12e8b53ac7d920b47b17c665972f8715">find_with</a> (K const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a12e8b53ac7d920b47b17c665972f8715"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code> using <code>pred</code> predicate for searching.  <a href="#a12e8b53ac7d920b47b17c665972f8715">More...</a><br/></td></tr>
<tr class="separator:a12e8b53ac7d920b47b17c665972f8715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d296b93c0f0d3b17defa97f2b1b49ce"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2d296b93c0f0d3b17defa97f2b1b49ce"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a2d296b93c0f0d3b17defa97f2b1b49ce">clear</a> ()</td></tr>
<tr class="memdesc:a2d296b93c0f0d3b17defa97f2b1b49ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the map. <br/></td></tr>
<tr class="separator:a2d296b93c0f0d3b17defa97f2b1b49ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78f1f05f54610b05308687bbd40e0924"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a78f1f05f54610b05308687bbd40e0924">empty</a> () const </td></tr>
<tr class="memdesc:a78f1f05f54610b05308687bbd40e0924"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the map is empty.  <a href="#a78f1f05f54610b05308687bbd40e0924">More...</a><br/></td></tr>
<tr class="separator:a78f1f05f54610b05308687bbd40e0924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e40fcd83414eb8de5a4d9a635656982"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e40fcd83414eb8de5a4d9a635656982"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a6e40fcd83414eb8de5a4d9a635656982">size</a> () const </td></tr>
<tr class="memdesc:a6e40fcd83414eb8de5a4d9a635656982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns item count in the map. <br/></td></tr>
<tr class="separator:a6e40fcd83414eb8de5a4d9a635656982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9598be5f08abb98d89ee8081c5a144a9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9598be5f08abb98d89ee8081c5a144a9"></a>
<a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a848b6a5a9e54bc26e634635b14a864a2">stat</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a9598be5f08abb98d89ee8081c5a144a9">statistics</a> () const </td></tr>
<tr class="memdesc:a9598be5f08abb98d89ee8081c5a144a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const reference to internal statistics. <br/></td></tr>
<tr class="separator:a9598be5f08abb98d89ee8081c5a144a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa2b0764097e0e34888c71efaba8c5b1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#afa2b0764097e0e34888c71efaba8c5b1">check_consistency</a> () const </td></tr>
<tr class="memdesc:afa2b0764097e0e34888c71efaba8c5b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks internal consistency (not atomic, not thread-safe)  <a href="#afa2b0764097e0e34888c71efaba8c5b1">More...</a><br/></td></tr>
<tr class="separator:afa2b0764097e0e34888c71efaba8c5b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html">cds::intrusive::EllenBinTree&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;</a></td></tr>
<tr class="memitem:aad038f808e1c52cba16bd09c044ae9a0 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad038f808e1c52cba16bd09c044ae9a0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#aad038f808e1c52cba16bd09c044ae9a0">EllenBinTree</a> ()</td></tr>
<tr class="memdesc:aad038f808e1c52cba16bd09c044ae9a0 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br/></td></tr>
<tr class="separator:aad038f808e1c52cba16bd09c044ae9a0 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce6aaf0ca14b0731c0db3a61e7d4012 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ce6aaf0ca14b0731c0db3a61e7d4012"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a6ce6aaf0ca14b0731c0db3a61e7d4012">~EllenBinTree</a> ()</td></tr>
<tr class="memdesc:a6ce6aaf0ca14b0731c0db3a61e7d4012 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the tree. <br/></td></tr>
<tr class="separator:a6ce6aaf0ca14b0731c0db3a61e7d4012 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02172bcb0d7173db7c6eae9967a1fa28 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a02172bcb0d7173db7c6eae9967a1fa28">insert</a> (<a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#add56a738dd647d7d4afee42ba853cd49">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:a02172bcb0d7173db7c6eae9967a1fa28 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a02172bcb0d7173db7c6eae9967a1fa28">More...</a><br/></td></tr>
<tr class="separator:a02172bcb0d7173db7c6eae9967a1fa28 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a720938b154f0d19179a7a92610ed459b inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:a720938b154f0d19179a7a92610ed459b inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a720938b154f0d19179a7a92610ed459b">insert</a> (<a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#add56a738dd647d7d4afee42ba853cd49">value_type</a> &amp;val, Func f)</td></tr>
<tr class="memdesc:a720938b154f0d19179a7a92610ed459b inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a720938b154f0d19179a7a92610ed459b">More...</a><br/></td></tr>
<tr class="separator:a720938b154f0d19179a7a92610ed459b inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96086eb88ec0537a00c69f2c3173489e inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:a96086eb88ec0537a00c69f2c3173489e inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a96086eb88ec0537a00c69f2c3173489e">ensure</a> (<a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#add56a738dd647d7d4afee42ba853cd49">value_type</a> &amp;val, Func func)</td></tr>
<tr class="memdesc:a96086eb88ec0537a00c69f2c3173489e inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that the <code>val</code> exists in the tree.  <a href="#a96086eb88ec0537a00c69f2c3173489e">More...</a><br/></td></tr>
<tr class="separator:a96086eb88ec0537a00c69f2c3173489e inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a973e6bffddd1f5edf3e35729d7d031a4 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a973e6bffddd1f5edf3e35729d7d031a4">unlink</a> (<a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#add56a738dd647d7d4afee42ba853cd49">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:a973e6bffddd1f5edf3e35729d7d031a4 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlinks the item <code>val</code> from the tree.  <a href="#a973e6bffddd1f5edf3e35729d7d031a4">More...</a><br/></td></tr>
<tr class="separator:a973e6bffddd1f5edf3e35729d7d031a4 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28bdeb008cdbe8fc85f7350a86a734fd inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:a28bdeb008cdbe8fc85f7350a86a734fd inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a28bdeb008cdbe8fc85f7350a86a734fd">erase</a> (const Q &amp;val)</td></tr>
<tr class="memdesc:a28bdeb008cdbe8fc85f7350a86a734fd inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the tree.  <a href="#a28bdeb008cdbe8fc85f7350a86a734fd">More...</a><br/></td></tr>
<tr class="separator:a28bdeb008cdbe8fc85f7350a86a734fd inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2139489e597ce28bdeb551a154fd67c2 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less &gt; </td></tr>
<tr class="memitem:a2139489e597ce28bdeb551a154fd67c2 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a2139489e597ce28bdeb551a154fd67c2">erase_with</a> (const Q &amp;val, Less pred)</td></tr>
<tr class="memdesc:a2139489e597ce28bdeb551a154fd67c2 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the item from the tree with comparing functor <code>pred</code>.  <a href="#a2139489e597ce28bdeb551a154fd67c2">More...</a><br/></td></tr>
<tr class="separator:a2139489e597ce28bdeb551a154fd67c2 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae320a229094d5925b446aa6602222906 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:ae320a229094d5925b446aa6602222906 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ae320a229094d5925b446aa6602222906">erase</a> (Q const &amp;val, Func f)</td></tr>
<tr class="memdesc:ae320a229094d5925b446aa6602222906 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the tree.  <a href="#ae320a229094d5925b446aa6602222906">More...</a><br/></td></tr>
<tr class="separator:ae320a229094d5925b446aa6602222906 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca62084ba8240726a0135c4cea7927ea inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:aca62084ba8240726a0135c4cea7927ea inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#aca62084ba8240726a0135c4cea7927ea">erase_with</a> (Q const &amp;val, Less pred, Func f)</td></tr>
<tr class="memdesc:aca62084ba8240726a0135c4cea7927ea inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the item from the tree with comparing functor <code>pred</code>.  <a href="#aca62084ba8240726a0135c4cea7927ea">More...</a><br/></td></tr>
<tr class="separator:aca62084ba8240726a0135c4cea7927ea inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a475d6c5b83df7def3176ec1fe0c7bf04 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#add56a738dd647d7d4afee42ba853cd49">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a475d6c5b83df7def3176ec1fe0c7bf04">extract_min</a> ()</td></tr>
<tr class="memdesc:a475d6c5b83df7def3176ec1fe0c7bf04 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an item with minimal key from the tree.  <a href="#a475d6c5b83df7def3176ec1fe0c7bf04">More...</a><br/></td></tr>
<tr class="separator:a475d6c5b83df7def3176ec1fe0c7bf04 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cb88ea9ab8737d8241c7464973078a4 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#add56a738dd647d7d4afee42ba853cd49">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a0cb88ea9ab8737d8241c7464973078a4">extract_max</a> ()</td></tr>
<tr class="memdesc:a0cb88ea9ab8737d8241c7464973078a4 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an item with maximal key from the tree.  <a href="#a0cb88ea9ab8737d8241c7464973078a4">More...</a><br/></td></tr>
<tr class="separator:a0cb88ea9ab8737d8241c7464973078a4 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace8ee44a408dc41ac55c59e508e5d975 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:ace8ee44a408dc41ac55c59e508e5d975 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#add56a738dd647d7d4afee42ba853cd49">value_type</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ace8ee44a408dc41ac55c59e508e5d975">extract</a> (Q const &amp;val)</td></tr>
<tr class="memdesc:ace8ee44a408dc41ac55c59e508e5d975 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an item from the tree.  <a href="#ace8ee44a408dc41ac55c59e508e5d975">More...</a><br/></td></tr>
<tr class="separator:ace8ee44a408dc41ac55c59e508e5d975 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69eb5676aa73c10e71b55b2dd8d9e563 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less &gt; </td></tr>
<tr class="memitem:a69eb5676aa73c10e71b55b2dd8d9e563 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#add56a738dd647d7d4afee42ba853cd49">value_type</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a69eb5676aa73c10e71b55b2dd8d9e563">extract_with</a> (Q const &amp;val, Less pred)</td></tr>
<tr class="memdesc:a69eb5676aa73c10e71b55b2dd8d9e563 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an item from the set using <code>pred</code> for searching.  <a href="#a69eb5676aa73c10e71b55b2dd8d9e563">More...</a><br/></td></tr>
<tr class="separator:a69eb5676aa73c10e71b55b2dd8d9e563 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2efa077bde2f8d228ca34695fb18b691 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:a2efa077bde2f8d228ca34695fb18b691 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a2efa077bde2f8d228ca34695fb18b691">find</a> (Q const &amp;val) const </td></tr>
<tr class="memdesc:a2efa077bde2f8d228ca34695fb18b691 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code>.  <a href="#a2efa077bde2f8d228ca34695fb18b691">More...</a><br/></td></tr>
<tr class="separator:a2efa077bde2f8d228ca34695fb18b691 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a1d90aa74177fea20157877ff4a3037 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less &gt; </td></tr>
<tr class="memitem:a3a1d90aa74177fea20157877ff4a3037 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a3a1d90aa74177fea20157877ff4a3037">find_with</a> (Q const &amp;val, Less pred) const </td></tr>
<tr class="memdesc:a3a1d90aa74177fea20157877ff4a3037 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code> with comparing functor <code>pred</code>.  <a href="#a3a1d90aa74177fea20157877ff4a3037">More...</a><br/></td></tr>
<tr class="separator:a3a1d90aa74177fea20157877ff4a3037 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a6ffa668b871e0d173132b3fa596ef9 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:a9a6ffa668b871e0d173132b3fa596ef9 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a9a6ffa668b871e0d173132b3fa596ef9">find</a> (Q &amp;val, Func f) const </td></tr>
<tr class="memdesc:a9a6ffa668b871e0d173132b3fa596ef9 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code>.  <a href="#a9a6ffa668b871e0d173132b3fa596ef9">More...</a><br/></td></tr>
<tr class="separator:a9a6ffa668b871e0d173132b3fa596ef9 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ce3da11463c7408609ffd81c9e77d7 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:a63ce3da11463c7408609ffd81c9e77d7 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a63ce3da11463c7408609ffd81c9e77d7">find_with</a> (Q &amp;val, Less pred, Func f) const </td></tr>
<tr class="memdesc:a63ce3da11463c7408609ffd81c9e77d7 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code> with comparing functor <code>pred</code>.  <a href="#a63ce3da11463c7408609ffd81c9e77d7">More...</a><br/></td></tr>
<tr class="separator:a63ce3da11463c7408609ffd81c9e77d7 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8307e68cbc51a2ca215bb2df33c4041 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:ae8307e68cbc51a2ca215bb2df33c4041 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ae8307e68cbc51a2ca215bb2df33c4041">find</a> (Q const &amp;val, Func f) const </td></tr>
<tr class="memdesc:ae8307e68cbc51a2ca215bb2df33c4041 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code>.  <a href="#ae8307e68cbc51a2ca215bb2df33c4041">More...</a><br/></td></tr>
<tr class="separator:ae8307e68cbc51a2ca215bb2df33c4041 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af191700f7f5fa0579ab3178aa936e405 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:af191700f7f5fa0579ab3178aa936e405 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#af191700f7f5fa0579ab3178aa936e405">find_with</a> (Q const &amp;val, Less pred, Func f) const </td></tr>
<tr class="memdesc:af191700f7f5fa0579ab3178aa936e405 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code> with comparing functor <code>pred</code>.  <a href="#af191700f7f5fa0579ab3178aa936e405">More...</a><br/></td></tr>
<tr class="separator:af191700f7f5fa0579ab3178aa936e405 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a229deaa9345b5f9c858f2e05dbf357ce inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a229deaa9345b5f9c858f2e05dbf357ce"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a229deaa9345b5f9c858f2e05dbf357ce">empty</a> () const </td></tr>
<tr class="memdesc:a229deaa9345b5f9c858f2e05dbf357ce inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the tree is empty. <br/></td></tr>
<tr class="separator:a229deaa9345b5f9c858f2e05dbf357ce inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9de3ae3ed073bf0e9b7890551d3d113c inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a9de3ae3ed073bf0e9b7890551d3d113c">clear</a> ()</td></tr>
<tr class="memdesc:a9de3ae3ed073bf0e9b7890551d3d113c inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the tree (non-atomic)  <a href="#a9de3ae3ed073bf0e9b7890551d3d113c">More...</a><br/></td></tr>
<tr class="separator:a9de3ae3ed073bf0e9b7890551d3d113c inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a864f1ab0d1f40d330a1e6815c315482d inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a864f1ab0d1f40d330a1e6815c315482d">size</a> () const </td></tr>
<tr class="memdesc:a864f1ab0d1f40d330a1e6815c315482d inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns item count in the tree.  <a href="#a864f1ab0d1f40d330a1e6815c315482d">More...</a><br/></td></tr>
<tr class="separator:a864f1ab0d1f40d330a1e6815c315482d inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8619c8794b92e04f9115b11af571d446 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8619c8794b92e04f9115b11af571d446"></a>
<a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#af1aa9f8188ea6d8a45aaf8d22a712173">stat</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a8619c8794b92e04f9115b11af571d446">statistics</a> () const </td></tr>
<tr class="memdesc:a8619c8794b92e04f9115b11af571d446 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const reference to internal statistics. <br/></td></tr>
<tr class="separator:a8619c8794b92e04f9115b11af571d446 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1caa29830fbf8664dcc3611e23d3ec0a inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a1caa29830fbf8664dcc3611e23d3ec0a">check_consistency</a> () const </td></tr>
<tr class="memdesc:a1caa29830fbf8664dcc3611e23d3ec0a inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks internal consistency (not atomic, not thread-safe)  <a href="#a1caa29830fbf8664dcc3611e23d3ec0a">More...</a><br/></td></tr>
<tr class="separator:a1caa29830fbf8664dcc3611e23d3ec0a inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_attribs_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html">cds::intrusive::EllenBinTree&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;</a></td></tr>
<tr class="memitem:a3e7f05c5f6483acbc00aa7ede418730f inherit pro_attribs_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e7f05c5f6483acbc00aa7ede418730f"></a>
<a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#abf5e22a713d77a11d5ae1bf80377b4d9">item_counter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a3e7f05c5f6483acbc00aa7ede418730f">m_ItemCounter</a></td></tr>
<tr class="memdesc:a3e7f05c5f6483acbc00aa7ede418730f inherit pro_attribs_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">item counter <br/></td></tr>
<tr class="separator:a3e7f05c5f6483acbc00aa7ede418730f inherit pro_attribs_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72420a225c0fd08e642748ce756e72c7 inherit pro_attribs_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a72420a225c0fd08e642748ce756e72c7"></a>
<a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#af1aa9f8188ea6d8a45aaf8d22a712173">stat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a72420a225c0fd08e642748ce756e72c7">m_Stat</a></td></tr>
<tr class="memdesc:a72420a225c0fd08e642748ce756e72c7 inherit pro_attribs_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal statistics <br/></td></tr>
<tr class="separator:a72420a225c0fd08e642748ce756e72c7 inherit pro_attribs_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class RCU, typename Key, typename T, class Traits = ellen_bintree::type_traits&gt;<br/>
class cds::container::EllenBinTreeMap&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;</h3>

<p>Map based on Ellen's et al binary search tree (RCU specialization) </p>
<p><a class="anchor" id="cds_container_EllenBinTreeMap_rcu"></a> Source:</p>
<ul>
<li>[2010] F.Ellen, P.Fatourou, E.Ruppert, F.van Breugel "Non-blocking Binary Search Tree"</li>
</ul>
<p>EllenBinTreeMap is an unbalanced leaf-oriented binary search tree that implements the <em>map</em> abstract data type. Nodes maintains child pointers but not parent pointers. Every internal node has exactly two children, and all data of type <code>std::pair&lt;Key const, T&gt;</code> currently in the tree are stored in the leaves. Internal nodes of the tree are used to direct <code>find</code> operation along the path to the correct leaf. The keys (of <code>Key</code> type) stored in internal nodes may or may not be in the map. Unlike <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#cds_container_EllenBinTreeSet_rcu">EllenBinTreeSet</a> keys are not a part of <code>T</code> type. The map can be represented as a set containing <code>std::pair&lt; Key const, T&gt; </code> values.</p>
<p>Due to <code>extract_min</code> and <code>extract_max</code> member functions the <code>EllenBinTreeMap</code> can act as a <em>priority queue</em>. In this case you should provide unique compound key, for example, the priority value plus some uniformly distributed random value.</p>
<dl class="section warning"><dt>Warning</dt><dd>Recall the tree is <b>unbalanced</b>. The complexity of operations is <code>O(log N)</code> for uniformly distributed random keys, but in worst case the complexity is <code>O(N)</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>In the current implementation we do not use helping technique described in original paper. So, the current implementation is near to fine-grained lock-based tree. Helping will be implemented in future release</dd></dl>
<p><b>Template arguments</b> :</p>
<ul>
<li><code>RCU</code> - one of <a class="el" href="namespacecds_1_1urcu.html#cds_urcu_gc">RCU type</a></li>
<li><code>Key</code> - key type</li>
<li><code>T</code> - value type to be stored in tree's leaf nodes.</li>
<li><code>Traits</code> - type traits. See <a class="el" href="structcds_1_1container_1_1ellen__bintree_1_1type__traits.html" title="Type traits for EllenBinTreeSet, EllenBinTreeMap and EllenBinTreePriorityQueue. ">ellen_bintree::type_traits</a> for explanation.</li>
</ul>
<p>It is possible to declare option-based tree with <a class="el" href="structcds_1_1container_1_1ellen__bintree_1_1make__map__traits.html" title="Metafunction converting option list to EllenBinTreeMap traits. ">ellen_bintree::make_map_traits</a> metafunction instead of <code>Traits</code> template argument. Template argument list <code>Options</code> of <a class="el" href="structcds_1_1container_1_1ellen__bintree_1_1make__map__traits.html" title="Metafunction converting option list to EllenBinTreeMap traits. ">ellen_bintree::make_map_traits</a> metafunction are:</p>
<ul>
<li><a class="el" href="structcds_1_1opt_1_1compare.html" title="[type-option] Option setter for key comparing ">opt::compare</a> - key compare functor. No default functor is provided. If the option is not specified, <code>opt::less</code> is used.</li>
<li><a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate ">opt::less</a> - specifies binary predicate used for key compare. At least <code>opt::compare</code> or <code>opt::less</code> should be defined.</li>
<li><a class="el" href="structcds_1_1opt_1_1item__counter.html" title="[type-option] Option setter for item counting ">opt::item_counter</a> - the type of item counting feature. Default is <a class="el" href="classcds_1_1atomicity_1_1empty__item__counter.html">atomicity::empty_item_counter</a> that is no item counting.</li>
<li><a class="el" href="structcds_1_1opt_1_1memory__model.html" title="[type-option] Option setter for C++ memory model ">opt::memory_model</a> - C++ memory ordering model. Can be <a class="el" href="structcds_1_1opt_1_1v_1_1relaxed__ordering.html" title="Relaxed memory ordering model. ">opt::v::relaxed_ordering</a> (relaxed memory model, the default) or <a class="el" href="structcds_1_1opt_1_1v_1_1sequential__consistent.html" title="Sequential consistent memory ordering model. ">opt::v::sequential_consistent</a> (sequentially consisnent memory model).</li>
<li><a class="el" href="structcds_1_1opt_1_1allocator.html" title="[type-option] Option setter for an allocator ">opt::allocator</a> - the allocator used for <a class="el" href="structcds_1_1container_1_1ellen__bintree_1_1map__node.html">leaf nodes</a> which contains data. Default is <a class="el" href="user__setup_2allocator_8h.html#ad5fb7e3cbe8cf24295f0ea3c165a2d82">CDS_DEFAULT_ALLOCATOR</a>.</li>
<li><a class="el" href="structcds_1_1opt_1_1node__allocator.html" title="[type-option] Option setter for node allocator ">opt::node_allocator</a> - the allocator used for <a class="el" href="namespacecds_1_1container_1_1ellen__bintree.html#a7812cc4170a56eea568d9ed894825297">internal nodes</a>. Default is <a class="el" href="user__setup_2allocator_8h.html#ad5fb7e3cbe8cf24295f0ea3c165a2d82">CDS_DEFAULT_ALLOCATOR</a>.</li>
<li><a class="el" href="namespacecds_1_1container_1_1ellen__bintree.html#abf67b3b7bf47458b02ec081665adec0c" title="Typedef for cds::intrusive::ellen_bintree::update_desc_allocator. ">ellen_bintree::update_desc_allocator</a> - an allocator of <a class="el" href="namespacecds_1_1container_1_1ellen__bintree.html#ab6afc9f1cee19f542868b7cb3541400f">update descriptors</a>, default is <a class="el" href="user__setup_2allocator_8h.html#ad5fb7e3cbe8cf24295f0ea3c165a2d82">CDS_DEFAULT_ALLOCATOR</a>. Note that update descriptor is helping data structure with short lifetime and it is good candidate for pooling. The number of simultaneously existing descriptors is a relatively small number limited the number of threads working with the tree and RCU buffer size. Therefore, a bounded lock-free container like <code><a class="el" href="classcds_1_1container_1_1_vyukov_m_p_m_c_cycle_queue.html" title="Vyukov&#39;s MPMC bounded queue. ">cds::container::VyukovMPMCCycleQueue</a></code> is good choice for the free-list of update descriptors, see <a class="el" href="classcds_1_1memory_1_1vyukov__queue__pool.html" title="Free-list based on bounded lock-free queue cds::intrusive::VyukovMPMCCycleQueue. ">cds::memory::vyukov_queue_pool</a> free-list implementation. Also notice that size of update descriptor is not dependent on the type of data stored in the tree so single free-list object can be used for several EllenBinTree-based object.</li>
<li><a class="el" href="structcds_1_1opt_1_1stat.html" title="[type-option] Generic option setter for statisitcs ">opt::stat</a> - internal statistics. Available types: <a class="el" href="namespacecds_1_1container_1_1ellen__bintree.html#a26d24a3f54d0d1f97ddccfa2bb2d95a8" title="Typedef for cds::intrusive::ellen_bintree::stat. ">ellen_bintree::stat</a>, <a class="el" href="namespacecds_1_1container_1_1ellen__bintree.html#a995a1808963654d80b3175a55ffdfe9a" title="Typedef for cds::intrusive::ellen_bintree::empty_stat. ">ellen_bintree::empty_stat</a> (the default)</li>
<li><a class="el" href="structcds_1_1opt_1_1rcu__check__deadlock.html" title="[type-option] RCU check deadlock option setter ">opt::rcu_check_deadlock</a> - a deadlock checking policy. Default is <a class="el" href="structcds_1_1opt_1_1v_1_1rcu__throw__deadlock.html" title="opt::rcu_check_deadlock option value: throw a cds::urcu::rcu_deadlock exception when a deadlock detec...">opt::v::rcu_throw_deadlock</a></li>
<li><a class="el" href="structcds_1_1opt_1_1copy__policy.html" title="Copy policy option. ">opt::copy_policy</a> - key copy policy defines a functor to copy leaf node's key to internal node. By default, assignment operator is used. The copy functor interface is: <div class="fragment"><div class="line"><span class="keyword">struct </span>copy_functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( Key&amp; dest, Key <span class="keyword">const</span>&amp; src ) ;</div>
<div class="line">};</div>
</div><!-- fragment --></li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Before including <code>&lt;cds/container/ellen_bintree_map_rcu.h&gt;</code> you should include appropriate RCU header file, see <a class="el" href="namespacecds_1_1urcu.html#cds_urcu_gc">RCU type</a> for list of existing RCU class and corresponding header files. </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="afa2b0764097e0e34888c71efaba8c5b1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html">cds::container::EllenBinTreeMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::check_consistency </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks internal consistency (not atomic, not thread-safe) </p>
<p>The debugging function to check internal consistency of the tree. </p>

</div>
</div>
<a class="anchor" id="a58e53d25d3058462581d14d8134fdca1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html">cds::container::EllenBinTreeMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For key <code>key</code> inserts data of type <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a3baf873ae293f63b5b5ff6431515e68e">value_type</a> constructed with <code>std::forward&lt;Args&gt;(args)...</code> </p>
<p>Returns <code>true</code> if inserting successful, <code>false</code> otherwise.</p>
<p>RCU <code>synchronize</code> method can be called. RCU should not be locked.</p>
<dl class="section note"><dt>Note</dt><dd>This function is available only for compiler that supports variadic template and move semantics </dd></dl>

</div>
</div>
<a class="anchor" id="a78f1f05f54610b05308687bbd40e0924"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html">cds::container::EllenBinTreeMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the map is empty. </p>
<p>Emptiness is checked by item counting: if item count is zero then the map is empty. </p>

</div>
</div>
<a class="anchor" id="ab9069f247464eaa2ab5821220a4ad679"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;bool, bool&gt; <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html">cds::container::EllenBinTreeMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::ensure </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensures that the <code>key</code> exists in the map. </p>
<p>The operation performs inserting or changing data with lock-free manner.</p>
<p>If the <code>key</code> not found in the map, then the new item created from <code>key</code> is inserted into the map (note that in this case the <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#acab0193fda53d0ae8de2733329057eda">key_type</a> should be constructible from type <code>K</code>). Otherwise, the functor <code>func</code> is called with item found. The functor <code>Func</code> may be a function with signature: </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> func( <span class="keywordtype">bool</span> bNew, <a class="code" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a3baf873ae293f63b5b5ff6431515e68e">value_type</a>&amp; item ) ;</div>
</div><!-- fragment --><p> or a functor: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>my_functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <span class="keywordtype">bool</span> bNew, <a class="code" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a3baf873ae293f63b5b5ff6431515e68e">value_type</a>&amp; item ) ;</div>
<div class="line">};</div>
</div><!-- fragment --><p>with arguments:</p>
<ul>
<li><code>bNew</code> - <code>true</code> if the item has been inserted, <code>false</code> otherwise</li>
<li><code>item</code> - item of the list</li>
</ul>
<p>The functor may change any fields of the <code>item.second</code> that is <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a3baf873ae293f63b5b5ff6431515e68e">value_type</a>.</p>
<p>You may pass <code>func</code> argument by reference using <code>boost::ref</code>.</p>
<p>RCU <code>synchronize</code> method can be called. RCU should not be locked.</p>
<p>Returns <code> std::pair&lt;bool, bool&gt; </code> where <code>first</code> is true if operation is successfull, <code>second</code> is true if new item has been added or <code>false</code> if the item with <code>key</code> already is in the list. </p>

</div>
</div>
<a class="anchor" id="aef6901ac037b94518242d4cdb4c03530"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html">cds::container::EllenBinTreeMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete <code>key</code> from the map. </p>
<p><a class="anchor" id="cds_nonintrusive_EllenBinTreeMap_rcu_erase_val"></a> RCU <code>synchronize</code> method can be called. RCU should not be locked.</p>
<p>Return <code>true</code> if <code>key</code> is found and deleted, <code>false</code> otherwise </p>

</div>
</div>
<a class="anchor" id="a116b712f8cd1096ae4ff3bc308368c06"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html">cds::container::EllenBinTreeMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete <code>key</code> from the map. </p>
<p><a class="anchor" id="cds_nonintrusive_EllenBinTreeMap_rcu_erase_func"></a> The function searches an item with key <code>key</code>, calls <code>f</code> functor and deletes the item. If <code>key</code> is not found, the functor is not called.</p>
<p>The functor <code>Func</code> interface: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>extractor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()(<a class="code" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a3baf873ae293f63b5b5ff6431515e68e">value_type</a>&amp; item) { ... }</div>
<div class="line">};</div>
</div><!-- fragment --><p> The functor may be passed by reference using <code>boost:ref</code></p>
<p>RCU <code>synchronize</code> method can be called. RCU should not be locked.</p>
<p>Return <code>true</code> if key is found and deleted, <code>false</code> otherwise </p>

</div>
</div>
<a class="anchor" id="a6a95ba4ead2f0010620ce8821b7a81ca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html">cds::container::EllenBinTreeMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the map using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#cds_nonintrusive_EllenBinTreeMap_rcu_erase_val">erase(K const&amp;)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the map. </p>

</div>
</div>
<a class="anchor" id="a4b93a7ed5880dacdc5e8f8e8e63e614c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html">cds::container::EllenBinTreeMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the map using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#cds_nonintrusive_EllenBinTreeMap_rcu_erase_func">erase(K const&amp;, Func)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the map. </p>

</div>
</div>
<a class="anchor" id="ab30d6ba1f3d4ebaec9cf0ca1aff42ad7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html">cds::container::EllenBinTreeMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::extract_max </td>
          <td>(</td>
          <td class="paramtype">std::pair&lt; <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#acab0193fda53d0ae8de2733329057eda">key_type</a>, <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a1faa61720dd1c60f5a27bcd5fcc5fe06">mapped_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts an item with maximal key from the map. </p>
<p>If the map is not empty, the function returns <code>true</code>, <code>dest</code> contains the copy of maximum key/value pair (assignment operator is called for <code>value_type</code>). If the map is empty, the function returns <code>false</code>, <code>dest</code> is left unchanged.</p>
<dl class="section note"><dt>Note</dt><dd>Due the concurrent nature of the map, the function extracts <em>nearly</em> maximal key. It means that the function gets rightmost leaf of the tree and tries to unlink it. During unlinking, a concurrent thread may insert an item with key great than leftmost item's key. So, the function returns the item with maximum key at the moment of tree traversing.</dd></dl>
<p>RCU <code>synchronize</code> method can be called. RCU should not be locked. </p>

</div>
</div>
<a class="anchor" id="ac4ae0bf487db2bddcb7e32391cf7a843"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html">cds::container::EllenBinTreeMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::extract_max </td>
          <td>(</td>
          <td class="paramtype">Q &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts an item with maximal key from the map. </p>
<p>If the map is not empty, the function returns <code>true</code>, <code>f</code> functor is called with value found. If the map is empty, the function returns <code>false</code>, <code>f</code> functor is not called, <code>dest</code> is left unchanged.</p>
<p>The functor <code>Func</code> interface is: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>extract_functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( Q&amp; dest, <a class="code" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a3baf873ae293f63b5b5ff6431515e68e">value_type</a>&amp; valueFound ) ;</div>
<div class="line">};</div>
</div><!-- fragment --><p> The functor should copy interesting part of value found into <code>dest</code>. <code>f</code> can be passed by value or by reference using <code>boost::ref</code> or cds::ref.</p>
<dl class="section note"><dt>Note</dt><dd>Due the concurrent nature of the map, the function extracts <em>nearly</em> maximal key. It means that the function gets rightmost leaf of the tree and tries to unlink it. During unlinking, a concurrent thread may insert an item with key great than leftmost item's key. So, the function returns the item with maximum key at the moment of tree traversing.</dd></dl>
<p>RCU <code>synchronize</code> method can be called. RCU should not be locked. </p>

</div>
</div>
<a class="anchor" id="aa5da9bbd15dcdf65504574636d4beae0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html">cds::container::EllenBinTreeMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::extract_min </td>
          <td>(</td>
          <td class="paramtype">std::pair&lt; <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#acab0193fda53d0ae8de2733329057eda">key_type</a>, <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a1faa61720dd1c60f5a27bcd5fcc5fe06">mapped_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts an item with minimal key from the map. </p>
<p>If the map is not empty, the function returns <code>true</code>, <code>dest</code> contains the copy of minimum key/value pair (assignment operator is called for <code>value_type</code>). If the map is empty, the function returns <code>false</code>, <code>dest</code> is left unchanged.</p>
<dl class="section note"><dt>Note</dt><dd>Due the concurrent nature of the map, the function extracts <em>nearly</em> minimum key. It means that the function gets leftmost leaf of the tree and tries to unlink it. During unlinking, a concurrent thread may insert an item with key less than leftmost item's key. So, the function returns the item with minimum key at the moment of tree traversing.</dd></dl>
<p>RCU <code>synchronize</code> method can be called. RCU should not be locked. </p>

</div>
</div>
<a class="anchor" id="a64c5c4c3545cd75ac8abf5ab07e96c7d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html">cds::container::EllenBinTreeMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::extract_min </td>
          <td>(</td>
          <td class="paramtype">Q &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts an item with minimal key from the map. </p>
<p>If the map is not empty, the function returns <code>true</code>, <code>f</code> functor is called with value found. If the map is empty, the function returns <code>false</code>, <code>f</code> functor is not called, <code>dest</code> is left unchanged.</p>
<p>The functor <code>Func</code> interface is: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>extract_functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( Q&amp; dest, <a class="code" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a3baf873ae293f63b5b5ff6431515e68e">value_type</a>&amp; valueFound ) ;</div>
<div class="line">};</div>
</div><!-- fragment --><p> The functor should copy interesting part of value found into <code>dest</code>. <code>f</code> can be passed by value or by reference using <code>boost::ref</code> or cds::ref.</p>
<dl class="section note"><dt>Note</dt><dd>Due the concurrent nature of the map, the function extracts <em>nearly</em> minimum key. It means that the function gets leftmost leaf of the tree and tries to unlink it. During unlinking, a concurrent thread may insert an item with key less than leftmost item's key. So, the function returns the item with minimum key at the moment of tree traversing.</dd></dl>
<p>RCU <code>synchronize</code> method can be called. RCU should not be locked. </p>

</div>
</div>
<a class="anchor" id="a4625f995111e1a99db7bacd8cb04ae52"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html">cds::container::EllenBinTreeMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::find </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the key <code>key</code>. </p>
<p><a class="anchor" id="cds_nonintrusive_EllenBinTreeMap_rcu_find_cfunc"></a> The function searches the item with key equal to <code>key</code> and calls the functor <code>f</code> for item found. The interface of <code>Func</code> functor is: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a3baf873ae293f63b5b5ff6431515e68e">value_type</a>&amp; item ) ;</div>
<div class="line">};</div>
</div><!-- fragment --><p> where <code>item</code> is the item found.</p>
<p>You can pass <code>f</code> argument by reference using <code>boost::ref</code> or cds::ref.</p>
<p>The functor may change <code>item.second</code>.</p>
<p>The function applies RCU lock internally.</p>
<p>The function returns <code>true</code> if <code>key</code> is found, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a97ebcd10766ce469899465887029a0e0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html">cds::container::EllenBinTreeMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::find </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the key <code>key</code>. </p>
<p><a class="anchor" id="cds_nonintrusive_EllenBinTreeMap_rcu_find_val"></a> The function searches the item with key equal to <code>key</code> and returns <code>true</code> if it is found, and <code>false</code> otherwise.</p>
<p>The function applies RCU lock internally. </p>

</div>
</div>
<a class="anchor" id="a38d967a6dfe520c46e2100f96b385d1d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html">cds::container::EllenBinTreeMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::find_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the key <code>val</code> using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#cds_nonintrusive_EllenBinTreeMap_rcu_find_cfunc">find(K const&amp;, Func)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the map. </p>

</div>
</div>
<a class="anchor" id="a12e8b53ac7d920b47b17c665972f8715"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html">cds::container::EllenBinTreeMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::find_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the key <code>val</code> using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#cds_nonintrusive_EllenBinTreeMap_rcu_find_val">find(K const&amp;)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the map. </p>

</div>
</div>
<a class="anchor" id="afbac8c1563935506629b0193064176f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html">cds::container::EllenBinTreeMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node with key and default value. </p>
<p>The function creates a node with <code>key</code> and default value, and then inserts the node created into the map.</p>
<p>Preconditions:</p>
<ul>
<li>The <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#acab0193fda53d0ae8de2733329057eda">key_type</a> should be constructible from a value of type <code>K</code>. In trivial case, <code>K</code> is equal to <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#acab0193fda53d0ae8de2733329057eda">key_type</a>.</li>
<li>The <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a1faa61720dd1c60f5a27bcd5fcc5fe06">mapped_type</a> should be default-constructible.</li>
</ul>
<p>RCU <code>synchronize</code> method can be called. RCU should not be locked.</p>
<p>Returns <code>true</code> if inserting successful, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a9f5084e9d0dbda621611870e65e25ed0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html">cds::container::EllenBinTreeMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V const &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node. </p>
<p>The function creates a node with copy of <code>val</code> value and then inserts the node created into the map.</p>
<p>Preconditions:</p>
<ul>
<li>The <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#acab0193fda53d0ae8de2733329057eda">key_type</a> should be constructible from <code>key</code> of type <code>K</code>.</li>
<li>The <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a3baf873ae293f63b5b5ff6431515e68e">value_type</a> should be constructible from <code>val</code> of type <code>V</code>.</li>
</ul>
<p>RCU <code>synchronize</code> method can be called. RCU should not be locked.</p>
<p>Returns <code>true</code> if <code>val</code> is inserted into the map, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a299decf525e9a001eb7f6ca5f4274390"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html">cds::container::EllenBinTreeMap</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::insert_key </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node and initialize it by a functor. </p>
<p>This function inserts new node with key <code>key</code> and if inserting is successful then it calls <code>func</code> functor with signature </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a3baf873ae293f63b5b5ff6431515e68e">value_type</a>&amp; item )  ;</div>
<div class="line">};</div>
</div><!-- fragment --><p>The argument <code>item</code> of user-defined functor <code>func</code> is the reference to the map's item inserted:</p>
<ul>
<li><code>item.first</code> is a const reference to item's key that cannot be changed.</li>
<li><code>item.second</code> is a reference to item's value that may be changed.</li>
</ul>
<p>The user-defined functor can be passed by reference using <code>boost::ref</code> and it is called only if inserting is successful.</p>
<p>The key_type should be constructible from value of type <code>K</code>.</p>
<p>The function allows to split creating of new item into two part:</p>
<ul>
<li>create item from <code>key</code>;</li>
<li>insert new item into the map;</li>
<li>if inserting is successful, initialize the value of item by calling <code>func</code> functor</li>
</ul>
<p>This can be useful if complete initialization of object of <code>value_type</code> is heavyweight and it is preferable that the initialization should be completed only if inserting is successful.</p>
<p>RCU <code>synchronize</code> method can be called. RCU should not be locked. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>cds/container/ellen_bintree_map_rcu.h</li>
</ul>
</div><!-- contents -->
		<hr/>
		<div align="right">
			<b>cds</b> <b>1.5.0</b> 
			Developed by <i>Maxim Khiszinsky aka khizmax</i> 2007 - 2012
			<br/>
			<i>Autogenerated Sat Dec 28 2013 15:04:02 by Doxygen 1.8.5</i>
		</div>
	</BODY>
</HTML>
