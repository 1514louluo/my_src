<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>cds: cds::container::EllenBinTreeMap&lt; GC, Key, T, Traits &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">cds
   &#160;<span id="projectnumber">1.5.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecds.html">cds</a></li><li class="navelem"><a class="el" href="namespacecds_1_1container.html">container</a></li><li class="navelem"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html">EllenBinTreeMap</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">cds::container::EllenBinTreeMap&lt; GC, Key, T, Traits &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__cds__nonintrusive__map.html">Map</a> &#124; <a class="el" href="group__cds__nonintrusive__tree.html">Tree</a> &#124; <a class="el" href="group__cds__nonintrusive__priority__queue.html">Priority queue</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Map based on Ellen's et al binary search tree.  
 <a href="classcds_1_1container_1_1_ellen_bin_tree_map.html#details">More...</a></p>

<p><code>#include &lt;cds/container/ellen_bintree_map_impl.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cds::container::EllenBinTreeMap&lt; GC, Key, T, Traits &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcds_1_1container_1_1_ellen_bin_tree_map.png" usemap="#cds::container::EllenBinTreeMap&lt; GC, Key, T, Traits &gt;_map" alt=""/>
  <map id="cds::container::EllenBinTreeMap&lt; GC, Key, T, Traits &gt;_map" name="cds::container::EllenBinTreeMap&lt; GC, Key, T, Traits &gt;_map">
<area href="classcds_1_1intrusive_1_1_ellen_bin_tree.html" title="Ellen&#39;s et al binary search tree. " alt="cds::intrusive::EllenBinTree&lt; GC, Key, T, Traits &gt;" shape="rect" coords="0,0,323,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ab1485e508f29c790cd6ebac817e167f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab1485e508f29c790cd6ebac817e167f0"></a>
typedef GC&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#ab1485e508f29c790cd6ebac817e167f0">gc</a></td></tr>
<tr class="memdesc:ab1485e508f29c790cd6ebac817e167f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Garbage collector. <br/></td></tr>
<tr class="separator:ab1485e508f29c790cd6ebac817e167f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a108822eb86b7fad23777e9e1894cbb56"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a108822eb86b7fad23777e9e1894cbb56"></a>
typedef Key&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#a108822eb86b7fad23777e9e1894cbb56">key_type</a></td></tr>
<tr class="memdesc:a108822eb86b7fad23777e9e1894cbb56"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of a key stored in the map <br/></td></tr>
<tr class="separator:a108822eb86b7fad23777e9e1894cbb56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ef5c676743c86c13332bec26a846412"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ef5c676743c86c13332bec26a846412"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#a0ef5c676743c86c13332bec26a846412">mapped_type</a></td></tr>
<tr class="memdesc:a0ef5c676743c86c13332bec26a846412"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of value stored in the map <br/></td></tr>
<tr class="separator:a0ef5c676743c86c13332bec26a846412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4765b80ba2ebc7d640523066ace98076"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4765b80ba2ebc7d640523066ace98076"></a>
typedef std::pair&lt; <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#a108822eb86b7fad23777e9e1894cbb56">key_type</a> <br class="typebreak"/>
const, <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#a0ef5c676743c86c13332bec26a846412">mapped_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#a4765b80ba2ebc7d640523066ace98076">value_type</a></td></tr>
<tr class="memdesc:a4765b80ba2ebc7d640523066ace98076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key-value pair stored in leaf node of the mp. <br/></td></tr>
<tr class="separator:a4765b80ba2ebc7d640523066ace98076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a197bf59ce79fe380094c84d854340be3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a197bf59ce79fe380094c84d854340be3"></a>
typedef Traits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#a197bf59ce79fe380094c84d854340be3">options</a></td></tr>
<tr class="memdesc:a197bf59ce79fe380094c84d854340be3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits template parameter. <br/></td></tr>
<tr class="separator:a197bf59ce79fe380094c84d854340be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ba2ec926ab9e7c509748a93f4f49fe8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ba2ec926ab9e7c509748a93f4f49fe8"></a>
typedef implementation_defined&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#a0ba2ec926ab9e7c509748a93f4f49fe8">key_comparator</a></td></tr>
<tr class="memdesc:a0ba2ec926ab9e7c509748a93f4f49fe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">key compare functor based on <a class="el" href="structcds_1_1opt_1_1compare.html" title="[type-option] Option setter for key comparing ">opt::compare</a> and <a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate ">opt::less</a> option setter. <br/></td></tr>
<tr class="separator:a0ba2ec926ab9e7c509748a93f4f49fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc956c42b67e0ee8f1cd0808cf7f08ff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afc956c42b67e0ee8f1cd0808cf7f08ff"></a>
typedef base_class::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#afc956c42b67e0ee8f1cd0808cf7f08ff">item_counter</a></td></tr>
<tr class="memdesc:afc956c42b67e0ee8f1cd0808cf7f08ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counting policy used. <br/></td></tr>
<tr class="separator:afc956c42b67e0ee8f1cd0808cf7f08ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ffbcf69ca2eb5f1638d98b8f822fdac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ffbcf69ca2eb5f1638d98b8f822fdac"></a>
typedef base_class::memory_model&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#a6ffbcf69ca2eb5f1638d98b8f822fdac">memory_model</a></td></tr>
<tr class="memdesc:a6ffbcf69ca2eb5f1638d98b8f822fdac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory ordering. See <a class="el" href="structcds_1_1opt_1_1memory__model.html" title="[type-option] Option setter for C++ memory model ">cds::opt::memory_model</a> option. <br/></td></tr>
<tr class="separator:a6ffbcf69ca2eb5f1638d98b8f822fdac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aebcfa2ab164ee80775a9b9f186e3f5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4aebcfa2ab164ee80775a9b9f186e3f5"></a>
typedef base_class::node_allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#a4aebcfa2ab164ee80775a9b9f186e3f5">node_allocator_type</a></td></tr>
<tr class="memdesc:a4aebcfa2ab164ee80775a9b9f186e3f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocator for maintaining internal node <br/></td></tr>
<tr class="separator:a4aebcfa2ab164ee80775a9b9f186e3f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa02d7cebb16474cedaf5c6265bd139f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa02d7cebb16474cedaf5c6265bd139f"></a>
typedef base_class::stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#aaa02d7cebb16474cedaf5c6265bd139f">stat</a></td></tr>
<tr class="memdesc:aaa02d7cebb16474cedaf5c6265bd139f"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal statistics type <br/></td></tr>
<tr class="separator:aaa02d7cebb16474cedaf5c6265bd139f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19274e771f28c249786bc0e9108ca23d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a19274e771f28c249786bc0e9108ca23d"></a>
typedef options::copy_policy&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#a19274e771f28c249786bc0e9108ca23d">copy_policy</a></td></tr>
<tr class="memdesc:a19274e771f28c249786bc0e9108ca23d"><td class="mdescLeft">&#160;</td><td class="mdescRight">key copy policy <br/></td></tr>
<tr class="separator:a19274e771f28c249786bc0e9108ca23d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae565e18cd598d284f982a20be2af87bc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae565e18cd598d284f982a20be2af87bc"></a>
typedef options::allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#ae565e18cd598d284f982a20be2af87bc">allocator_type</a></td></tr>
<tr class="memdesc:ae565e18cd598d284f982a20be2af87bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator for leaf nodes. <br/></td></tr>
<tr class="separator:ae565e18cd598d284f982a20be2af87bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fd075d7e695b6e3ade3a49408d3f324"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4fd075d7e695b6e3ade3a49408d3f324"></a>
typedef base_class::node_allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#a4fd075d7e695b6e3ade3a49408d3f324">node_allocator</a></td></tr>
<tr class="memdesc:a4fd075d7e695b6e3ade3a49408d3f324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal node allocator. <br/></td></tr>
<tr class="separator:a4fd075d7e695b6e3ade3a49408d3f324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c2cbecec73ad588211a65b6ad7d2d55"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c2cbecec73ad588211a65b6ad7d2d55"></a>
typedef <br class="typebreak"/>
base_class::update_desc_allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#a7c2cbecec73ad588211a65b6ad7d2d55">update_desc_allocator</a></td></tr>
<tr class="memdesc:a7c2cbecec73ad588211a65b6ad7d2d55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update descriptor allocator. <br/></td></tr>
<tr class="separator:a7c2cbecec73ad588211a65b6ad7d2d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html">cds::intrusive::EllenBinTree&lt; GC, Key, T, Traits &gt;</a></td></tr>
<tr class="memitem:a413c08fbf97b94fe58b1a16fb43fdc30 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a413c08fbf97b94fe58b1a16fb43fdc30"></a>
typedef GC&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#a413c08fbf97b94fe58b1a16fb43fdc30">gc</a></td></tr>
<tr class="memdesc:a413c08fbf97b94fe58b1a16fb43fdc30 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Garbage collector used. <br/></td></tr>
<tr class="separator:a413c08fbf97b94fe58b1a16fb43fdc30 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e4edbd33aad5489ef524d53cff9cfd6 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e4edbd33aad5489ef524d53cff9cfd6"></a>
typedef Key&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#a0e4edbd33aad5489ef524d53cff9cfd6">key_type</a></td></tr>
<tr class="memdesc:a0e4edbd33aad5489ef524d53cff9cfd6 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of a key stored in internal nodes; key is a part of <code>value_type</code> <br/></td></tr>
<tr class="separator:a0e4edbd33aad5489ef524d53cff9cfd6 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3131f31b2cbbfd725105ae9ca8c99e6 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae3131f31b2cbbfd725105ae9ca8c99e6"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#ae3131f31b2cbbfd725105ae9ca8c99e6">value_type</a></td></tr>
<tr class="memdesc:ae3131f31b2cbbfd725105ae9ca8c99e6 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of value stored in the binary tree <br/></td></tr>
<tr class="separator:ae3131f31b2cbbfd725105ae9ca8c99e6 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab10e40ca22ebc24dc38f93391cf6e595 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab10e40ca22ebc24dc38f93391cf6e595"></a>
typedef Traits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#ab10e40ca22ebc24dc38f93391cf6e595">options</a></td></tr>
<tr class="memdesc:ab10e40ca22ebc24dc38f93391cf6e595 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits template parameter. <br/></td></tr>
<tr class="separator:ab10e40ca22ebc24dc38f93391cf6e595 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34ab97b2c2f144699075d594832321de inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a34ab97b2c2f144699075d594832321de"></a>
typedef options::hook&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#a34ab97b2c2f144699075d594832321de">hook</a></td></tr>
<tr class="memdesc:a34ab97b2c2f144699075d594832321de inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">hook type <br/></td></tr>
<tr class="separator:a34ab97b2c2f144699075d594832321de inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c599dec5e7bec7b60cd0850ffacdd0a inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c599dec5e7bec7b60cd0850ffacdd0a"></a>
typedef hook::node_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#a3c599dec5e7bec7b60cd0850ffacdd0a">node_type</a></td></tr>
<tr class="memdesc:a3c599dec5e7bec7b60cd0850ffacdd0a inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">node type <br/></td></tr>
<tr class="separator:a3c599dec5e7bec7b60cd0850ffacdd0a inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af131f27b7d0df25edc1a58538e067ad4 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af131f27b7d0df25edc1a58538e067ad4"></a>
typedef options::disposer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#af131f27b7d0df25edc1a58538e067ad4">disposer</a></td></tr>
<tr class="memdesc:af131f27b7d0df25edc1a58538e067ad4 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">leaf node disposer <br/></td></tr>
<tr class="separator:af131f27b7d0df25edc1a58538e067ad4 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99ab0b8087d1c74e8d37ff544cb290d8 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a99ab0b8087d1c74e8d37ff544cb290d8"></a>
typedef implementation_defined&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#a99ab0b8087d1c74e8d37ff544cb290d8">key_comparator</a></td></tr>
<tr class="memdesc:a99ab0b8087d1c74e8d37ff544cb290d8 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">key compare functor based on <a class="el" href="structcds_1_1opt_1_1compare.html" title="[type-option] Option setter for key comparing ">opt::compare</a> and <a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate ">opt::less</a> option setter. <br/></td></tr>
<tr class="separator:a99ab0b8087d1c74e8d37ff544cb290d8 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac23bedac61a72afb4716acd97d19bc29 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac23bedac61a72afb4716acd97d19bc29"></a>
typedef <a class="el" href="structcds_1_1intrusive_1_1get__node__traits.html">get_node_traits</a><br class="typebreak"/>
&lt; <a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#ae3131f31b2cbbfd725105ae9ca8c99e6">value_type</a>, <a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#a3c599dec5e7bec7b60cd0850ffacdd0a">node_type</a>, <a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#a34ab97b2c2f144699075d594832321de">hook</a> &gt;<br class="typebreak"/>
::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#ac23bedac61a72afb4716acd97d19bc29">node_traits</a></td></tr>
<tr class="memdesc:ac23bedac61a72afb4716acd97d19bc29 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node traits. <br/></td></tr>
<tr class="separator:ac23bedac61a72afb4716acd97d19bc29 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643a24fcfeb9821e7fce2015d3dc3c15 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a643a24fcfeb9821e7fce2015d3dc3c15"></a>
typedef options::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#a643a24fcfeb9821e7fce2015d3dc3c15">item_counter</a></td></tr>
<tr class="memdesc:a643a24fcfeb9821e7fce2015d3dc3c15 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counting policy used. <br/></td></tr>
<tr class="separator:a643a24fcfeb9821e7fce2015d3dc3c15 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2a2b6f26d13004e53ce5530deb32284 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2a2b6f26d13004e53ce5530deb32284"></a>
typedef options::memory_model&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#aa2a2b6f26d13004e53ce5530deb32284">memory_model</a></td></tr>
<tr class="memdesc:aa2a2b6f26d13004e53ce5530deb32284 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory ordering. See <a class="el" href="structcds_1_1opt_1_1memory__model.html" title="[type-option] Option setter for C++ memory model ">cds::opt::memory_model</a> option. <br/></td></tr>
<tr class="separator:aa2a2b6f26d13004e53ce5530deb32284 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace4cf6d51a59d88758d6d161edbb81be inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace4cf6d51a59d88758d6d161edbb81be"></a>
typedef options::stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#ace4cf6d51a59d88758d6d161edbb81be">stat</a></td></tr>
<tr class="memdesc:ace4cf6d51a59d88758d6d161edbb81be inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal statistics type <br/></td></tr>
<tr class="separator:ace4cf6d51a59d88758d6d161edbb81be inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f8ca8da5433a67785ff3befc5fea04 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab3f8ca8da5433a67785ff3befc5fea04"></a>
typedef options::key_extractor&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#ab3f8ca8da5433a67785ff3befc5fea04">key_extractor</a></td></tr>
<tr class="memdesc:ab3f8ca8da5433a67785ff3befc5fea04 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">key extracting functor <br/></td></tr>
<tr class="separator:ab3f8ca8da5433a67785ff3befc5fea04 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72952c5677354f3a186e6ae5eba66235 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a72952c5677354f3a186e6ae5eba66235"></a>
typedef options::node_allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#a72952c5677354f3a186e6ae5eba66235">node_allocator</a></td></tr>
<tr class="memdesc:a72952c5677354f3a186e6ae5eba66235 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal node allocator. <br/></td></tr>
<tr class="separator:a72952c5677354f3a186e6ae5eba66235 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e46282c3ad09c1839b778769c506a16 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e46282c3ad09c1839b778769c506a16"></a>
typedef <br class="typebreak"/>
options::update_desc_allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#a1e46282c3ad09c1839b778769c506a16">update_desc_allocator</a></td></tr>
<tr class="memdesc:a1e46282c3ad09c1839b778769c506a16 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update descriptor allocator. <br/></td></tr>
<tr class="separator:a1e46282c3ad09c1839b778769c506a16 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a15eaea6e068143bc1fa120aaa7fc1567"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a15eaea6e068143bc1fa120aaa7fc1567"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#a15eaea6e068143bc1fa120aaa7fc1567">EllenBinTreeMap</a> ()</td></tr>
<tr class="memdesc:a15eaea6e068143bc1fa120aaa7fc1567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br/></td></tr>
<tr class="separator:a15eaea6e068143bc1fa120aaa7fc1567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaea644551c7eaf19b021276d24ba012"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afaea644551c7eaf19b021276d24ba012"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#afaea644551c7eaf19b021276d24ba012">~EllenBinTreeMap</a> ()</td></tr>
<tr class="memdesc:afaea644551c7eaf19b021276d24ba012"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the map. <br/></td></tr>
<tr class="separator:afaea644551c7eaf19b021276d24ba012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5542c4c3d6cd0e8e489722b6ffb154e3"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:a5542c4c3d6cd0e8e489722b6ffb154e3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#a5542c4c3d6cd0e8e489722b6ffb154e3">insert</a> (K const &amp;key)</td></tr>
<tr class="memdesc:a5542c4c3d6cd0e8e489722b6ffb154e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node with key and default value.  <a href="#a5542c4c3d6cd0e8e489722b6ffb154e3">More...</a><br/></td></tr>
<tr class="separator:a5542c4c3d6cd0e8e489722b6ffb154e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bc696cff7de22cfaf89c837bb91433f"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V &gt; </td></tr>
<tr class="memitem:a0bc696cff7de22cfaf89c837bb91433f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#a0bc696cff7de22cfaf89c837bb91433f">insert</a> (K const &amp;key, V const &amp;val)</td></tr>
<tr class="memdesc:a0bc696cff7de22cfaf89c837bb91433f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a0bc696cff7de22cfaf89c837bb91433f">More...</a><br/></td></tr>
<tr class="separator:a0bc696cff7de22cfaf89c837bb91433f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a0f2cb50593936ae632b260860202bb"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Func &gt; </td></tr>
<tr class="memitem:a3a0f2cb50593936ae632b260860202bb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#a3a0f2cb50593936ae632b260860202bb">insert_key</a> (const K &amp;key, Func func)</td></tr>
<tr class="memdesc:a3a0f2cb50593936ae632b260860202bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node and initialize it by a functor.  <a href="#a3a0f2cb50593936ae632b260860202bb">More...</a><br/></td></tr>
<tr class="separator:a3a0f2cb50593936ae632b260860202bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff4c43206fc7cde36c2f4d377f24adb8"><td class="memTemplParams" colspan="2">template&lt;typename K , typename... Args&gt; </td></tr>
<tr class="memitem:aff4c43206fc7cde36c2f4d377f24adb8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#aff4c43206fc7cde36c2f4d377f24adb8">emplace</a> (K &amp;&amp;key, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:aff4c43206fc7cde36c2f4d377f24adb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">For key <code>key</code> inserts data of type <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#a4765b80ba2ebc7d640523066ace98076">value_type</a> constructed with <code>std::forward&lt;Args&gt;(args)...</code>  <a href="#aff4c43206fc7cde36c2f4d377f24adb8">More...</a><br/></td></tr>
<tr class="separator:aff4c43206fc7cde36c2f4d377f24adb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b3addb642c2ef621d4832f2033f8bfc"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Func &gt; </td></tr>
<tr class="memitem:a6b3addb642c2ef621d4832f2033f8bfc"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#a6b3addb642c2ef621d4832f2033f8bfc">ensure</a> (K const &amp;key, Func func)</td></tr>
<tr class="memdesc:a6b3addb642c2ef621d4832f2033f8bfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that the <code>key</code> exists in the map.  <a href="#a6b3addb642c2ef621d4832f2033f8bfc">More...</a><br/></td></tr>
<tr class="separator:a6b3addb642c2ef621d4832f2033f8bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d524fa1dc31ff071360a5fea06935cb"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:a9d524fa1dc31ff071360a5fea06935cb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#a9d524fa1dc31ff071360a5fea06935cb">erase</a> (K const &amp;key)</td></tr>
<tr class="memdesc:a9d524fa1dc31ff071360a5fea06935cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete <code>key</code> from the map.  <a href="#a9d524fa1dc31ff071360a5fea06935cb">More...</a><br/></td></tr>
<tr class="separator:a9d524fa1dc31ff071360a5fea06935cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af828e15b9083848a45d5b5732b8dc12f"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less &gt; </td></tr>
<tr class="memitem:af828e15b9083848a45d5b5732b8dc12f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#af828e15b9083848a45d5b5732b8dc12f">erase_with</a> (K const &amp;key, Less pred)</td></tr>
<tr class="memdesc:af828e15b9083848a45d5b5732b8dc12f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the map using <code>pred</code> predicate for searching.  <a href="#af828e15b9083848a45d5b5732b8dc12f">More...</a><br/></td></tr>
<tr class="separator:af828e15b9083848a45d5b5732b8dc12f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad303b838cbd79a231b29bc9df0cc5f20"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Func &gt; </td></tr>
<tr class="memitem:ad303b838cbd79a231b29bc9df0cc5f20"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#ad303b838cbd79a231b29bc9df0cc5f20">erase</a> (K const &amp;key, Func f)</td></tr>
<tr class="memdesc:ad303b838cbd79a231b29bc9df0cc5f20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete <code>key</code> from the map.  <a href="#ad303b838cbd79a231b29bc9df0cc5f20">More...</a><br/></td></tr>
<tr class="separator:ad303b838cbd79a231b29bc9df0cc5f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aada0a824bdebbea7fd3990cd74577744"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:aada0a824bdebbea7fd3990cd74577744"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#aada0a824bdebbea7fd3990cd74577744">erase_with</a> (K const &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:aada0a824bdebbea7fd3990cd74577744"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the map using <code>pred</code> predicate for searching.  <a href="#aada0a824bdebbea7fd3990cd74577744">More...</a><br/></td></tr>
<tr class="separator:aada0a824bdebbea7fd3990cd74577744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fc134558b0b6abbf320b35affc7f184"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#a8fc134558b0b6abbf320b35affc7f184">extract_min</a> (std::pair&lt; <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#a108822eb86b7fad23777e9e1894cbb56">key_type</a>, <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#a0ef5c676743c86c13332bec26a846412">mapped_type</a> &gt; &amp;dest)</td></tr>
<tr class="memdesc:a8fc134558b0b6abbf320b35affc7f184"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an item with minimal key from the map.  <a href="#a8fc134558b0b6abbf320b35affc7f184">More...</a><br/></td></tr>
<tr class="separator:a8fc134558b0b6abbf320b35affc7f184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a264f7ebfa7a71fa508aa442e7869936a"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:a264f7ebfa7a71fa508aa442e7869936a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#a264f7ebfa7a71fa508aa442e7869936a">extract_min</a> (Q &amp;dest, Func f)</td></tr>
<tr class="memdesc:a264f7ebfa7a71fa508aa442e7869936a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an item with minimal key from the map.  <a href="#a264f7ebfa7a71fa508aa442e7869936a">More...</a><br/></td></tr>
<tr class="separator:a264f7ebfa7a71fa508aa442e7869936a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa06d26c896803829262613a3d2e22efc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#aa06d26c896803829262613a3d2e22efc">extract_max</a> (std::pair&lt; <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#a108822eb86b7fad23777e9e1894cbb56">key_type</a>, <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#a0ef5c676743c86c13332bec26a846412">mapped_type</a> &gt; &amp;dest)</td></tr>
<tr class="memdesc:aa06d26c896803829262613a3d2e22efc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an item with maximal key from the map.  <a href="#aa06d26c896803829262613a3d2e22efc">More...</a><br/></td></tr>
<tr class="separator:aa06d26c896803829262613a3d2e22efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7fc6191de02a9c8db3e85e8124545c8"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:ac7fc6191de02a9c8db3e85e8124545c8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#ac7fc6191de02a9c8db3e85e8124545c8">extract_max</a> (Q &amp;dest, Func f)</td></tr>
<tr class="memdesc:ac7fc6191de02a9c8db3e85e8124545c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an item with maximal key from the map.  <a href="#ac7fc6191de02a9c8db3e85e8124545c8">More...</a><br/></td></tr>
<tr class="separator:ac7fc6191de02a9c8db3e85e8124545c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc4f68cd845c6238cec46dc7c4508fb"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Func &gt; </td></tr>
<tr class="memitem:abfc4f68cd845c6238cec46dc7c4508fb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#abfc4f68cd845c6238cec46dc7c4508fb">find</a> (K const &amp;key, Func f)</td></tr>
<tr class="memdesc:abfc4f68cd845c6238cec46dc7c4508fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>key</code>.  <a href="#abfc4f68cd845c6238cec46dc7c4508fb">More...</a><br/></td></tr>
<tr class="separator:abfc4f68cd845c6238cec46dc7c4508fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee294922adcc222dc7f89f64bb902124"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:aee294922adcc222dc7f89f64bb902124"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#aee294922adcc222dc7f89f64bb902124">find_with</a> (K const &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:aee294922adcc222dc7f89f64bb902124"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code> using <code>pred</code> predicate for searching.  <a href="#aee294922adcc222dc7f89f64bb902124">More...</a><br/></td></tr>
<tr class="separator:aee294922adcc222dc7f89f64bb902124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6639fe17113e1e178141f1f0dfc44068"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:a6639fe17113e1e178141f1f0dfc44068"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#a6639fe17113e1e178141f1f0dfc44068">find</a> (K const &amp;key)</td></tr>
<tr class="memdesc:a6639fe17113e1e178141f1f0dfc44068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>key</code>.  <a href="#a6639fe17113e1e178141f1f0dfc44068">More...</a><br/></td></tr>
<tr class="separator:a6639fe17113e1e178141f1f0dfc44068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fd250d83d6c2d4f85b7f57cae6073b2"><td class="memTemplParams" colspan="2">template&lt;typename K , typename Less &gt; </td></tr>
<tr class="memitem:a5fd250d83d6c2d4f85b7f57cae6073b2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#a5fd250d83d6c2d4f85b7f57cae6073b2">find_with</a> (K const &amp;key, Less pred)</td></tr>
<tr class="memdesc:a5fd250d83d6c2d4f85b7f57cae6073b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code> using <code>pred</code> predicate for searching.  <a href="#a5fd250d83d6c2d4f85b7f57cae6073b2">More...</a><br/></td></tr>
<tr class="separator:a5fd250d83d6c2d4f85b7f57cae6073b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c9013d1b514f523badbe19518f55ee6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c9013d1b514f523badbe19518f55ee6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#a7c9013d1b514f523badbe19518f55ee6">clear</a> ()</td></tr>
<tr class="memdesc:a7c9013d1b514f523badbe19518f55ee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the map. <br/></td></tr>
<tr class="separator:a7c9013d1b514f523badbe19518f55ee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d8da53716ffd09b5b1507a4e2a8a9c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#a7d8da53716ffd09b5b1507a4e2a8a9c1">empty</a> () const </td></tr>
<tr class="memdesc:a7d8da53716ffd09b5b1507a4e2a8a9c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the map is empty.  <a href="#a7d8da53716ffd09b5b1507a4e2a8a9c1">More...</a><br/></td></tr>
<tr class="separator:a7d8da53716ffd09b5b1507a4e2a8a9c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0144e8a450e7d8e414e01cf30b9d9e0a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0144e8a450e7d8e414e01cf30b9d9e0a"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#a0144e8a450e7d8e414e01cf30b9d9e0a">size</a> () const </td></tr>
<tr class="memdesc:a0144e8a450e7d8e414e01cf30b9d9e0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns item count in the map. <br/></td></tr>
<tr class="separator:a0144e8a450e7d8e414e01cf30b9d9e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcfc3ff83ee1df69fed13b12064911b5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abcfc3ff83ee1df69fed13b12064911b5"></a>
<a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#aaa02d7cebb16474cedaf5c6265bd139f">stat</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#abcfc3ff83ee1df69fed13b12064911b5">statistics</a> () const </td></tr>
<tr class="memdesc:abcfc3ff83ee1df69fed13b12064911b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const reference to internal statistics. <br/></td></tr>
<tr class="separator:abcfc3ff83ee1df69fed13b12064911b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3bb756c1c089c8c8e767d1f83da25b8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#aa3bb756c1c089c8c8e767d1f83da25b8">check_consistency</a> () const </td></tr>
<tr class="memdesc:aa3bb756c1c089c8c8e767d1f83da25b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks internal consistency (not atomic, not thread-safe)  <a href="#aa3bb756c1c089c8c8e767d1f83da25b8">More...</a><br/></td></tr>
<tr class="separator:aa3bb756c1c089c8c8e767d1f83da25b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html">cds::intrusive::EllenBinTree&lt; GC, Key, T, Traits &gt;</a></td></tr>
<tr class="memitem:a384d04dfebb1bb014ab08a6884131536 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a384d04dfebb1bb014ab08a6884131536"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#a384d04dfebb1bb014ab08a6884131536">EllenBinTree</a> ()</td></tr>
<tr class="memdesc:a384d04dfebb1bb014ab08a6884131536 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br/></td></tr>
<tr class="separator:a384d04dfebb1bb014ab08a6884131536 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf3e82fcef7ec85b4338e4b0f317b8d inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adbf3e82fcef7ec85b4338e4b0f317b8d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#adbf3e82fcef7ec85b4338e4b0f317b8d">~EllenBinTree</a> ()</td></tr>
<tr class="memdesc:adbf3e82fcef7ec85b4338e4b0f317b8d inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the tree. <br/></td></tr>
<tr class="separator:adbf3e82fcef7ec85b4338e4b0f317b8d inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c43f98b99ad30b3ac6376e05af049db inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#a8c43f98b99ad30b3ac6376e05af049db">insert</a> (<a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#ae3131f31b2cbbfd725105ae9ca8c99e6">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:a8c43f98b99ad30b3ac6376e05af049db inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a8c43f98b99ad30b3ac6376e05af049db">More...</a><br/></td></tr>
<tr class="separator:a8c43f98b99ad30b3ac6376e05af049db inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31c4fbc7ce6d68b5bf5735322fd2e2f5 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:a31c4fbc7ce6d68b5bf5735322fd2e2f5 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#a31c4fbc7ce6d68b5bf5735322fd2e2f5">insert</a> (<a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#ae3131f31b2cbbfd725105ae9ca8c99e6">value_type</a> &amp;val, Func f)</td></tr>
<tr class="memdesc:a31c4fbc7ce6d68b5bf5735322fd2e2f5 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a31c4fbc7ce6d68b5bf5735322fd2e2f5">More...</a><br/></td></tr>
<tr class="separator:a31c4fbc7ce6d68b5bf5735322fd2e2f5 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac375c93b25a91b2870720d46b168110a inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:ac375c93b25a91b2870720d46b168110a inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#ac375c93b25a91b2870720d46b168110a">ensure</a> (<a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#ae3131f31b2cbbfd725105ae9ca8c99e6">value_type</a> &amp;val, Func func)</td></tr>
<tr class="memdesc:ac375c93b25a91b2870720d46b168110a inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that the <code>val</code> exists in the tree.  <a href="#ac375c93b25a91b2870720d46b168110a">More...</a><br/></td></tr>
<tr class="separator:ac375c93b25a91b2870720d46b168110a inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2a6c46b4b6d495c45d5a738adaf2807 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#ac2a6c46b4b6d495c45d5a738adaf2807">unlink</a> (<a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#ae3131f31b2cbbfd725105ae9ca8c99e6">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:ac2a6c46b4b6d495c45d5a738adaf2807 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlinks the item <code>val</code> from the tree.  <a href="#ac2a6c46b4b6d495c45d5a738adaf2807">More...</a><br/></td></tr>
<tr class="separator:ac2a6c46b4b6d495c45d5a738adaf2807 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7d61dfbf2bb2eaec910dfe72d2971ad inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:aa7d61dfbf2bb2eaec910dfe72d2971ad inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#aa7d61dfbf2bb2eaec910dfe72d2971ad">erase</a> (const Q &amp;val)</td></tr>
<tr class="memdesc:aa7d61dfbf2bb2eaec910dfe72d2971ad inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the tree.  <a href="#aa7d61dfbf2bb2eaec910dfe72d2971ad">More...</a><br/></td></tr>
<tr class="separator:aa7d61dfbf2bb2eaec910dfe72d2971ad inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefec225f967f5a69b73caf7884b83778 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less &gt; </td></tr>
<tr class="memitem:aefec225f967f5a69b73caf7884b83778 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#aefec225f967f5a69b73caf7884b83778">erase_with</a> (const Q &amp;val, Less pred)</td></tr>
<tr class="memdesc:aefec225f967f5a69b73caf7884b83778 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the item from the tree with comparing functor <code>pred</code>.  <a href="#aefec225f967f5a69b73caf7884b83778">More...</a><br/></td></tr>
<tr class="separator:aefec225f967f5a69b73caf7884b83778 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a788887b6b2ff39a708045de9e0eee548 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:a788887b6b2ff39a708045de9e0eee548 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#a788887b6b2ff39a708045de9e0eee548">erase</a> (Q const &amp;val, Func f)</td></tr>
<tr class="memdesc:a788887b6b2ff39a708045de9e0eee548 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the tree.  <a href="#a788887b6b2ff39a708045de9e0eee548">More...</a><br/></td></tr>
<tr class="separator:a788887b6b2ff39a708045de9e0eee548 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55f932bb7bc45e8565968d97d7f77444 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:a55f932bb7bc45e8565968d97d7f77444 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#a55f932bb7bc45e8565968d97d7f77444">erase_with</a> (Q const &amp;val, Less pred, Func f)</td></tr>
<tr class="memdesc:a55f932bb7bc45e8565968d97d7f77444 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the item from the tree with comparing functor <code>pred</code>.  <a href="#a55f932bb7bc45e8565968d97d7f77444">More...</a><br/></td></tr>
<tr class="separator:a55f932bb7bc45e8565968d97d7f77444 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25558c35ddcba60e6137be2d00bdbfe5 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#ae3131f31b2cbbfd725105ae9ca8c99e6">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#a25558c35ddcba60e6137be2d00bdbfe5">extract_min</a> ()</td></tr>
<tr class="memdesc:a25558c35ddcba60e6137be2d00bdbfe5 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an item with minimal key from the tree.  <a href="#a25558c35ddcba60e6137be2d00bdbfe5">More...</a><br/></td></tr>
<tr class="separator:a25558c35ddcba60e6137be2d00bdbfe5 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bf74c7c3f0da38b6ea59b17df19c55f inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#ae3131f31b2cbbfd725105ae9ca8c99e6">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#a6bf74c7c3f0da38b6ea59b17df19c55f">extract_max</a> ()</td></tr>
<tr class="memdesc:a6bf74c7c3f0da38b6ea59b17df19c55f inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an item with maximal key from the tree.  <a href="#a6bf74c7c3f0da38b6ea59b17df19c55f">More...</a><br/></td></tr>
<tr class="separator:a6bf74c7c3f0da38b6ea59b17df19c55f inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aefaed1082d574605ac737bb0ba5be4 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:a0aefaed1082d574605ac737bb0ba5be4 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#ae3131f31b2cbbfd725105ae9ca8c99e6">value_type</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#a0aefaed1082d574605ac737bb0ba5be4">extract</a> (Q const &amp;val)</td></tr>
<tr class="memdesc:a0aefaed1082d574605ac737bb0ba5be4 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an item from the tree.  <a href="#a0aefaed1082d574605ac737bb0ba5be4">More...</a><br/></td></tr>
<tr class="separator:a0aefaed1082d574605ac737bb0ba5be4 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a936dc6e16246a68a7cd30e4d4c62ef94 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less &gt; </td></tr>
<tr class="memitem:a936dc6e16246a68a7cd30e4d4c62ef94 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#ae3131f31b2cbbfd725105ae9ca8c99e6">value_type</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#a936dc6e16246a68a7cd30e4d4c62ef94">extract_with</a> (Q const &amp;val, Less pred)</td></tr>
<tr class="memdesc:a936dc6e16246a68a7cd30e4d4c62ef94 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an item from the set using <code>pred</code> for searching.  <a href="#a936dc6e16246a68a7cd30e4d4c62ef94">More...</a><br/></td></tr>
<tr class="separator:a936dc6e16246a68a7cd30e4d4c62ef94 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84e21d3bbdb7f2233ad321b2b41d1295 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:a84e21d3bbdb7f2233ad321b2b41d1295 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#a84e21d3bbdb7f2233ad321b2b41d1295">find</a> (Q const &amp;val)</td></tr>
<tr class="memdesc:a84e21d3bbdb7f2233ad321b2b41d1295 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code>.  <a href="#a84e21d3bbdb7f2233ad321b2b41d1295">More...</a><br/></td></tr>
<tr class="separator:a84e21d3bbdb7f2233ad321b2b41d1295 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd3c70d4ded131a0862bfb601b0c619 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less &gt; </td></tr>
<tr class="memitem:a0bd3c70d4ded131a0862bfb601b0c619 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#a0bd3c70d4ded131a0862bfb601b0c619">find_with</a> (Q const &amp;val, Less pred)</td></tr>
<tr class="memdesc:a0bd3c70d4ded131a0862bfb601b0c619 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code> with comparing functor <code>pred</code>.  <a href="#a0bd3c70d4ded131a0862bfb601b0c619">More...</a><br/></td></tr>
<tr class="separator:a0bd3c70d4ded131a0862bfb601b0c619 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bcc4f5a28b44c9446d0c0429be8c6de inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:a0bcc4f5a28b44c9446d0c0429be8c6de inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#a0bcc4f5a28b44c9446d0c0429be8c6de">find</a> (Q &amp;val, Func f)</td></tr>
<tr class="memdesc:a0bcc4f5a28b44c9446d0c0429be8c6de inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code>.  <a href="#a0bcc4f5a28b44c9446d0c0429be8c6de">More...</a><br/></td></tr>
<tr class="separator:a0bcc4f5a28b44c9446d0c0429be8c6de inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b9dcab6efef0ac9d0d59d1ce7991e31 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:a9b9dcab6efef0ac9d0d59d1ce7991e31 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#a9b9dcab6efef0ac9d0d59d1ce7991e31">find_with</a> (Q &amp;val, Less pred, Func f)</td></tr>
<tr class="memdesc:a9b9dcab6efef0ac9d0d59d1ce7991e31 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code> with comparing functor <code>pred</code>.  <a href="#a9b9dcab6efef0ac9d0d59d1ce7991e31">More...</a><br/></td></tr>
<tr class="separator:a9b9dcab6efef0ac9d0d59d1ce7991e31 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba15d4d07fa2e07d29b2ac961aa900cd inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:aba15d4d07fa2e07d29b2ac961aa900cd inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#aba15d4d07fa2e07d29b2ac961aa900cd">find</a> (Q const &amp;val, Func f)</td></tr>
<tr class="memdesc:aba15d4d07fa2e07d29b2ac961aa900cd inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code>.  <a href="#aba15d4d07fa2e07d29b2ac961aa900cd">More...</a><br/></td></tr>
<tr class="separator:aba15d4d07fa2e07d29b2ac961aa900cd inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31fd0c85c66f0d651e951005f8ae8afe inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:a31fd0c85c66f0d651e951005f8ae8afe inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#a31fd0c85c66f0d651e951005f8ae8afe">find_with</a> (Q const &amp;val, Less pred, Func f)</td></tr>
<tr class="memdesc:a31fd0c85c66f0d651e951005f8ae8afe inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code> with comparing functor <code>pred</code>.  <a href="#a31fd0c85c66f0d651e951005f8ae8afe">More...</a><br/></td></tr>
<tr class="separator:a31fd0c85c66f0d651e951005f8ae8afe inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ced6be78ddfa215b9f513841175ee22 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2ced6be78ddfa215b9f513841175ee22"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#a2ced6be78ddfa215b9f513841175ee22">empty</a> () const </td></tr>
<tr class="memdesc:a2ced6be78ddfa215b9f513841175ee22 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the tree is empty. <br/></td></tr>
<tr class="separator:a2ced6be78ddfa215b9f513841175ee22 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c0fe86f1ae1ff30607eecd18f64e258 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#a5c0fe86f1ae1ff30607eecd18f64e258">clear</a> ()</td></tr>
<tr class="memdesc:a5c0fe86f1ae1ff30607eecd18f64e258 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the tree (non-atomic)  <a href="#a5c0fe86f1ae1ff30607eecd18f64e258">More...</a><br/></td></tr>
<tr class="separator:a5c0fe86f1ae1ff30607eecd18f64e258 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5629e17edb6c97a68ab8c874c40c24e inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#af5629e17edb6c97a68ab8c874c40c24e">size</a> () const </td></tr>
<tr class="memdesc:af5629e17edb6c97a68ab8c874c40c24e inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns item count in the tree.  <a href="#af5629e17edb6c97a68ab8c874c40c24e">More...</a><br/></td></tr>
<tr class="separator:af5629e17edb6c97a68ab8c874c40c24e inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7601e7c16ffac7bd2b35c1981fec9e43 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7601e7c16ffac7bd2b35c1981fec9e43"></a>
<a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#ace4cf6d51a59d88758d6d161edbb81be">stat</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#a7601e7c16ffac7bd2b35c1981fec9e43">statistics</a> () const </td></tr>
<tr class="memdesc:a7601e7c16ffac7bd2b35c1981fec9e43 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const reference to internal statistics. <br/></td></tr>
<tr class="separator:a7601e7c16ffac7bd2b35c1981fec9e43 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b4655040fdac3b418980da060179253 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#a9b4655040fdac3b418980da060179253">check_consistency</a> () const </td></tr>
<tr class="memdesc:a9b4655040fdac3b418980da060179253 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks internal consistency (not atomic, not thread-safe)  <a href="#a9b4655040fdac3b418980da060179253">More...</a><br/></td></tr>
<tr class="separator:a9b4655040fdac3b418980da060179253 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_attribs_classcds_1_1intrusive_1_1_ellen_bin_tree"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classcds_1_1intrusive_1_1_ellen_bin_tree')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html">cds::intrusive::EllenBinTree&lt; GC, Key, T, Traits &gt;</a></td></tr>
<tr class="memitem:a2aa7e98673d7e142f3f13b35d64834ba inherit pro_attribs_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2aa7e98673d7e142f3f13b35d64834ba"></a>
<a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#a643a24fcfeb9821e7fce2015d3dc3c15">item_counter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#a2aa7e98673d7e142f3f13b35d64834ba">m_ItemCounter</a></td></tr>
<tr class="memdesc:a2aa7e98673d7e142f3f13b35d64834ba inherit pro_attribs_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">item counter <br/></td></tr>
<tr class="separator:a2aa7e98673d7e142f3f13b35d64834ba inherit pro_attribs_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1208d9558392fbb129b605a1c6a8bdd inherit pro_attribs_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad1208d9558392fbb129b605a1c6a8bdd"></a>
<a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#ace4cf6d51a59d88758d6d161edbb81be">stat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree.html#ad1208d9558392fbb129b605a1c6a8bdd">m_Stat</a></td></tr>
<tr class="memdesc:ad1208d9558392fbb129b605a1c6a8bdd inherit pro_attribs_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal statistics <br/></td></tr>
<tr class="separator:ad1208d9558392fbb129b605a1c6a8bdd inherit pro_attribs_classcds_1_1intrusive_1_1_ellen_bin_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class GC, typename Key, typename T, class Traits = ellen_bintree::type_traits&gt;<br/>
class cds::container::EllenBinTreeMap&lt; GC, Key, T, Traits &gt;</h3>

<p>Map based on Ellen's et al binary search tree. </p>
<p><a class="anchor" id="cds_container_EllenBinTreeMap"></a> Source:</p>
<ul>
<li>[2010] F.Ellen, P.Fatourou, E.Ruppert, F.van Breugel "Non-blocking Binary Search Tree"</li>
</ul>
<p>EllenBinTreeMap is an unbalanced leaf-oriented binary search tree that implements the <em>map</em> abstract data type. Nodes maintains child pointers but not parent pointers. Every internal node has exactly two children, and all data of type <code>std::pair&lt;Key const, T&gt;</code> currently in the tree are stored in the leaves. Internal nodes of the tree are used to direct <code>find</code> operation along the path to the correct leaf. The keys (of <code>Key</code> type) stored in internal nodes may or may not be in the map. Unlike <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html#cds_container_EllenBinTreeSet">EllenBinTreeSet</a> keys are not a part of <code>T</code> type. The map can be represented as a set containing <code>std::pair&lt; Key const, T&gt; </code> values.</p>
<p>Due to <code>extract_min</code> and <code>extract_max</code> member functions the <code>EllenBinTreeMap</code> can act as a <em>priority queue</em>. In this case you should provide unique compound key, for example, the priority value plus some uniformly distributed random value.</p>
<dl class="section warning"><dt>Warning</dt><dd>Recall the tree is <b>unbalanced</b>. The complexity of operations is <code>O(log N)</code> for uniformly distributed random keys, but in worst case the complexity is <code>O(N)</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>In the current implementation we do not use helping technique described in original paper. So, the current implementation is near to fine-grained lock-based tree. Helping will be implemented in future release</dd></dl>
<p><b>Template arguments</b> :</p>
<ul>
<li><code>GC</code> - safe memory reclamation (i.e. light-weight garbage collector) type, like <a class="el" href="classcds_1_1gc_1_1_h_p.html" title="Hazard Pointer garbage collector. ">cds::gc::HP</a>, <a class="el" href="classcds_1_1gc_1_1_p_t_b.html" title="Pass-the-Buck garbage collector. ">cds::gc::PTB</a> Note that <a class="el" href="classcds_1_1gc_1_1_h_r_c.html" title="Gidenstam&#39;s garbage collector. ">cds::gc::HRC</a> is not supported.</li>
<li><code>Key</code> - key type</li>
<li><code>T</code> - value type to be stored in tree's leaf nodes.</li>
<li><code>Traits</code> - type traits. See <a class="el" href="structcds_1_1container_1_1ellen__bintree_1_1type__traits.html" title="Type traits for EllenBinTreeSet, EllenBinTreeMap and EllenBinTreePriorityQueue. ">ellen_bintree::type_traits</a> for explanation.</li>
</ul>
<p>It is possible to declare option-based tree with <a class="el" href="structcds_1_1container_1_1ellen__bintree_1_1make__map__traits.html" title="Metafunction converting option list to EllenBinTreeMap traits. ">ellen_bintree::make_map_traits</a> metafunction instead of <code>Traits</code> template argument. Template argument list <code>Options</code> of <a class="el" href="structcds_1_1container_1_1ellen__bintree_1_1make__map__traits.html" title="Metafunction converting option list to EllenBinTreeMap traits. ">ellen_bintree::make_map_traits</a> metafunction are:</p>
<ul>
<li><a class="el" href="structcds_1_1opt_1_1compare.html" title="[type-option] Option setter for key comparing ">opt::compare</a> - key compare functor. No default functor is provided. If the option is not specified, <code>opt::less</code> is used.</li>
<li><a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate ">opt::less</a> - specifies binary predicate used for key compare. At least <code>opt::compare</code> or <code>opt::less</code> should be defined.</li>
<li><a class="el" href="structcds_1_1opt_1_1item__counter.html" title="[type-option] Option setter for item counting ">opt::item_counter</a> - the type of item counting feature. Default is <a class="el" href="classcds_1_1atomicity_1_1empty__item__counter.html">atomicity::empty_item_counter</a> that is no item counting.</li>
<li><a class="el" href="structcds_1_1opt_1_1memory__model.html" title="[type-option] Option setter for C++ memory model ">opt::memory_model</a> - C++ memory ordering model. Can be <a class="el" href="structcds_1_1opt_1_1v_1_1relaxed__ordering.html" title="Relaxed memory ordering model. ">opt::v::relaxed_ordering</a> (relaxed memory model, the default) or <a class="el" href="structcds_1_1opt_1_1v_1_1sequential__consistent.html" title="Sequential consistent memory ordering model. ">opt::v::sequential_consistent</a> (sequentially consisnent memory model).</li>
<li><a class="el" href="structcds_1_1opt_1_1allocator.html" title="[type-option] Option setter for an allocator ">opt::allocator</a> - the allocator used for <a class="el" href="structcds_1_1container_1_1ellen__bintree_1_1map__node.html">leaf nodes</a> which contains data. Default is <a class="el" href="user__setup_2allocator_8h.html#ad5fb7e3cbe8cf24295f0ea3c165a2d82">CDS_DEFAULT_ALLOCATOR</a>.</li>
<li><a class="el" href="structcds_1_1opt_1_1node__allocator.html" title="[type-option] Option setter for node allocator ">opt::node_allocator</a> - the allocator used for <a class="el" href="namespacecds_1_1container_1_1ellen__bintree.html#a7812cc4170a56eea568d9ed894825297">internal nodes</a>. Default is <a class="el" href="user__setup_2allocator_8h.html#ad5fb7e3cbe8cf24295f0ea3c165a2d82">CDS_DEFAULT_ALLOCATOR</a>.</li>
<li><a class="el" href="namespacecds_1_1container_1_1ellen__bintree.html#abf67b3b7bf47458b02ec081665adec0c" title="Typedef for cds::intrusive::ellen_bintree::update_desc_allocator. ">ellen_bintree::update_desc_allocator</a> - an allocator of <a class="el" href="namespacecds_1_1container_1_1ellen__bintree.html#ab6afc9f1cee19f542868b7cb3541400f">update descriptors</a>, default is <a class="el" href="user__setup_2allocator_8h.html#ad5fb7e3cbe8cf24295f0ea3c165a2d82">CDS_DEFAULT_ALLOCATOR</a>. Note that update descriptor is helping data structure with short lifetime and it is good candidate for pooling. The number of simultaneously existing descriptors is a relatively small number limited the number of threads working with the tree and GC buffer size. Therefore, a bounded lock-free container like <code><a class="el" href="classcds_1_1container_1_1_vyukov_m_p_m_c_cycle_queue.html" title="Vyukov&#39;s MPMC bounded queue. ">cds::container::VyukovMPMCCycleQueue</a></code> is good choice for the free-list of update descriptors, see <a class="el" href="classcds_1_1memory_1_1vyukov__queue__pool.html" title="Free-list based on bounded lock-free queue cds::intrusive::VyukovMPMCCycleQueue. ">cds::memory::vyukov_queue_pool</a> free-list implementation. Also notice that size of update descriptor is not dependent on the type of data stored in the tree so single free-list object can be used for several EllenBinTree-based object.</li>
<li><a class="el" href="structcds_1_1opt_1_1stat.html" title="[type-option] Generic option setter for statisitcs ">opt::stat</a> - internal statistics. Available types: <a class="el" href="namespacecds_1_1container_1_1ellen__bintree.html#a26d24a3f54d0d1f97ddccfa2bb2d95a8" title="Typedef for cds::intrusive::ellen_bintree::stat. ">ellen_bintree::stat</a>, <a class="el" href="namespacecds_1_1container_1_1ellen__bintree.html#a995a1808963654d80b3175a55ffdfe9a" title="Typedef for cds::intrusive::ellen_bintree::empty_stat. ">ellen_bintree::empty_stat</a> (the default)</li>
<li><a class="el" href="structcds_1_1opt_1_1copy__policy.html" title="Copy policy option. ">opt::copy_policy</a> - key copy policy defines a functor to copy leaf node's key to internal node. By default, assignment operator is used. The copy functor interface is: <div class="fragment"><div class="line"><span class="keyword">struct </span>copy_functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( Key&amp; dest, Key <span class="keyword">const</span>&amp; src ) ;</div>
<div class="line">};</div>
</div><!-- fragment --></li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Do not include <code>&lt;cds/container/ellen_bintree_map_impl.h&gt;</code> header file directly. There are header file for each GC type:<ul>
<li><code>&lt;cds/container/ellen_bintree_map_hp.h&gt;</code> - for Hazard Pointer GC <a class="el" href="classcds_1_1gc_1_1_h_p.html" title="Hazard Pointer garbage collector. ">cds::gc::HP</a></li>
<li><code>&lt;cds/container/ellen_bintree_map_ptb.h&gt;</code> - for Pass-the-Buck GC <a class="el" href="classcds_1_1gc_1_1_p_t_b.html" title="Pass-the-Buck garbage collector. ">cds::gc::PTB</a></li>
<li><code>&lt;cds/container/ellen_bintree_map_rcu.h&gt;</code> - for RCU GC (see <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#cds_container_EllenBinTreeMap_rcu">RCU-based EllenBinTreeMap</a>) </li>
</ul>
</dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aa3bb756c1c089c8c8e767d1f83da25b8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html">cds::container::EllenBinTreeMap</a>&lt; GC, Key, T, Traits &gt;::check_consistency </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks internal consistency (not atomic, not thread-safe) </p>
<p>The debugging function to check internal consistency of the tree. </p>

</div>
</div>
<a class="anchor" id="aff4c43206fc7cde36c2f4d377f24adb8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html">cds::container::EllenBinTreeMap</a>&lt; GC, Key, T, Traits &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For key <code>key</code> inserts data of type <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#a4765b80ba2ebc7d640523066ace98076">value_type</a> constructed with <code>std::forward&lt;Args&gt;(args)...</code> </p>
<p>Returns <code>true</code> if inserting successful, <code>false</code> otherwise.</p>
<dl class="section note"><dt>Note</dt><dd>This function is available only for compiler that supports variadic template and move semantics </dd></dl>

</div>
</div>
<a class="anchor" id="a7d8da53716ffd09b5b1507a4e2a8a9c1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html">cds::container::EllenBinTreeMap</a>&lt; GC, Key, T, Traits &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the map is empty. </p>
<p>Emptiness is checked by item counting: if item count is zero then the map is empty. </p>

</div>
</div>
<a class="anchor" id="a6b3addb642c2ef621d4832f2033f8bfc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;bool, bool&gt; <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html">cds::container::EllenBinTreeMap</a>&lt; GC, Key, T, Traits &gt;::ensure </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensures that the <code>key</code> exists in the map. </p>
<p>The operation performs inserting or changing data with lock-free manner.</p>
<p>If the <code>key</code> not found in the map, then the new item created from <code>key</code> is inserted into the map (note that in this case the <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#a108822eb86b7fad23777e9e1894cbb56">key_type</a> should be constructible from type <code>K</code>). Otherwise, the functor <code>func</code> is called with item found. The functor <code>Func</code> may be a function with signature: </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> func( <span class="keywordtype">bool</span> bNew, <a class="code" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#a4765b80ba2ebc7d640523066ace98076">value_type</a>&amp; item ) ;</div>
</div><!-- fragment --><p> or a functor: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>my_functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <span class="keywordtype">bool</span> bNew, <a class="code" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#a4765b80ba2ebc7d640523066ace98076">value_type</a>&amp; item ) ;</div>
<div class="line">};</div>
</div><!-- fragment --><p>with arguments:</p>
<ul>
<li><code>bNew</code> - <code>true</code> if the item has been inserted, <code>false</code> otherwise</li>
<li><code>item</code> - item of the list</li>
</ul>
<p>The functor may change any fields of the <code>item.second</code> that is <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#a4765b80ba2ebc7d640523066ace98076">value_type</a>.</p>
<p>You may pass <code>func</code> argument by reference using <code>boost::ref</code>.</p>
<p>Returns <code> std::pair&lt;bool, bool&gt; </code> where <code>first</code> is true if operation is successfull, <code>second</code> is true if new item has been added or <code>false</code> if the item with <code>key</code> already is in the list. </p>

</div>
</div>
<a class="anchor" id="a9d524fa1dc31ff071360a5fea06935cb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html">cds::container::EllenBinTreeMap</a>&lt; GC, Key, T, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete <code>key</code> from the map. </p>
<p><a class="anchor" id="cds_nonintrusive_EllenBinTreeMap_erase_val"></a> Return <code>true</code> if <code>key</code> is found and deleted, <code>false</code> otherwise </p>

</div>
</div>
<a class="anchor" id="ad303b838cbd79a231b29bc9df0cc5f20"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html">cds::container::EllenBinTreeMap</a>&lt; GC, Key, T, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete <code>key</code> from the map. </p>
<p><a class="anchor" id="cds_nonintrusive_EllenBinTreeMap_erase_func"></a> The function searches an item with key <code>key</code>, calls <code>f</code> functor and deletes the item. If <code>key</code> is not found, the functor is not called.</p>
<p>The functor <code>Func</code> interface: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>extractor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()(<a class="code" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#a4765b80ba2ebc7d640523066ace98076">value_type</a>&amp; item) { ... }</div>
<div class="line">};</div>
</div><!-- fragment --><p> The functor may be passed by reference using <code>boost:ref</code></p>
<p>Return <code>true</code> if key is found and deleted, <code>false</code> otherwise </p>

</div>
</div>
<a class="anchor" id="af828e15b9083848a45d5b5732b8dc12f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html">cds::container::EllenBinTreeMap</a>&lt; GC, Key, T, Traits &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the map using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#cds_nonintrusive_EllenBinTreeMap_erase_val">erase(K const&amp;)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the map. </p>

</div>
</div>
<a class="anchor" id="aada0a824bdebbea7fd3990cd74577744"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html">cds::container::EllenBinTreeMap</a>&lt; GC, Key, T, Traits &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the map using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#cds_nonintrusive_EllenBinTreeMap_erase_func">erase(K const&amp;, Func)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the map. </p>

</div>
</div>
<a class="anchor" id="aa06d26c896803829262613a3d2e22efc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html">cds::container::EllenBinTreeMap</a>&lt; GC, Key, T, Traits &gt;::extract_max </td>
          <td>(</td>
          <td class="paramtype">std::pair&lt; <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#a108822eb86b7fad23777e9e1894cbb56">key_type</a>, <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#a0ef5c676743c86c13332bec26a846412">mapped_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts an item with maximal key from the map. </p>
<p>If the map is not empty, the function returns <code>true</code>, <code>dest</code> contains the copy of maximum key/value pair (assignment operator is called for <code>value_type</code>). If the map is empty, the function returns <code>false</code>, <code>dest</code> is left unchanged.</p>
<dl class="section note"><dt>Note</dt><dd>Due the concurrent nature of the map, the function extracts <em>nearly</em> maximal key. It means that the function gets rightmost leaf of the tree and tries to unlink it. During unlinking, a concurrent thread may insert an item with key great than leftmost item's key. So, the function returns the item with maximum key at the moment of tree traversing. </dd></dl>

</div>
</div>
<a class="anchor" id="ac7fc6191de02a9c8db3e85e8124545c8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html">cds::container::EllenBinTreeMap</a>&lt; GC, Key, T, Traits &gt;::extract_max </td>
          <td>(</td>
          <td class="paramtype">Q &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts an item with maximal key from the map. </p>
<p>If the map is not empty, the function returns <code>true</code>, <code>f</code> functor is called with value found. If the map is empty, the function returns <code>false</code>, <code>f</code> functor is not called, <code>dest</code> is left unchanged.</p>
<p>The functor <code>Func</code> interface is: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>extract_functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( Q&amp; dest, <a class="code" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#a4765b80ba2ebc7d640523066ace98076">value_type</a>&amp; valueFound ) ;</div>
<div class="line">};</div>
</div><!-- fragment --><p> The functor should copy interesting part of value found into <code>dest</code>. <code>f</code> can be passed by value or by reference using <code>boost::ref</code> or cds::ref.</p>
<dl class="section note"><dt>Note</dt><dd>Due the concurrent nature of the map, the function extracts <em>nearly</em> maximal key. It means that the function gets rightmost leaf of the tree and tries to unlink it. During unlinking, a concurrent thread may insert an item with key great than leftmost item's key. So, the function returns the item with maximum key at the moment of tree traversing. </dd></dl>

</div>
</div>
<a class="anchor" id="a8fc134558b0b6abbf320b35affc7f184"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html">cds::container::EllenBinTreeMap</a>&lt; GC, Key, T, Traits &gt;::extract_min </td>
          <td>(</td>
          <td class="paramtype">std::pair&lt; <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#a108822eb86b7fad23777e9e1894cbb56">key_type</a>, <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#a0ef5c676743c86c13332bec26a846412">mapped_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts an item with minimal key from the map. </p>
<p>If the map is not empty, the function returns <code>true</code>, <code>dest</code> contains the copy of minimum key/value pair (assignment operator is called for <code>value_type</code>). If the map is empty, the function returns <code>false</code>, <code>dest</code> is left unchanged.</p>
<dl class="section note"><dt>Note</dt><dd>Due the concurrent nature of the map, the function extracts <em>nearly</em> minimum key. It means that the function gets leftmost leaf of the tree and tries to unlink it. During unlinking, a concurrent thread may insert an item with key less than leftmost item's key. So, the function returns the item with minimum key at the moment of tree traversing. </dd></dl>

</div>
</div>
<a class="anchor" id="a264f7ebfa7a71fa508aa442e7869936a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html">cds::container::EllenBinTreeMap</a>&lt; GC, Key, T, Traits &gt;::extract_min </td>
          <td>(</td>
          <td class="paramtype">Q &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts an item with minimal key from the map. </p>
<p>If the map is not empty, the function returns <code>true</code>, <code>f</code> functor is called with value found. If the map is empty, the function returns <code>false</code>, <code>f</code> functor is not called, <code>dest</code> is left unchanged.</p>
<p>The functor <code>Func</code> interface is: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>extract_functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( Q&amp; dest, <a class="code" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#a4765b80ba2ebc7d640523066ace98076">value_type</a>&amp; valueFound ) ;</div>
<div class="line">};</div>
</div><!-- fragment --><p> The functor should copy interesting part of value found into <code>dest</code>. <code>f</code> can be passed by value or by reference using <code>boost::ref</code> or cds::ref.</p>
<dl class="section note"><dt>Note</dt><dd>Due the concurrent nature of the map, the function extracts <em>nearly</em> minimum key. It means that the function gets leftmost leaf of the tree and tries to unlink it. During unlinking, a concurrent thread may insert an item with key less than leftmost item's key. So, the function returns the item with minimum key at the moment of tree traversing. </dd></dl>

</div>
</div>
<a class="anchor" id="abfc4f68cd845c6238cec46dc7c4508fb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html">cds::container::EllenBinTreeMap</a>&lt; GC, Key, T, Traits &gt;::find </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the key <code>key</code>. </p>
<p><a class="anchor" id="cds_nonintrusive_EllenBinTreeMap_find_cfunc"></a> The function searches the item with key equal to <code>key</code> and calls the functor <code>f</code> for item found. The interface of <code>Func</code> functor is: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#a4765b80ba2ebc7d640523066ace98076">value_type</a>&amp; item ) ;</div>
<div class="line">};</div>
</div><!-- fragment --><p> where <code>item</code> is the item found.</p>
<p>You can pass <code>f</code> argument by reference using <code>boost::ref</code> or cds::ref.</p>
<p>The functor may change <code>item.second</code>.</p>
<p>The function returns <code>true</code> if <code>key</code> is found, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a6639fe17113e1e178141f1f0dfc44068"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html">cds::container::EllenBinTreeMap</a>&lt; GC, Key, T, Traits &gt;::find </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the key <code>key</code>. </p>
<p><a class="anchor" id="cds_nonintrusive_EllenBinTreeMap_find_val"></a> The function searches the item with key equal to <code>key</code> and returns <code>true</code> if it is found, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="aee294922adcc222dc7f89f64bb902124"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html">cds::container::EllenBinTreeMap</a>&lt; GC, Key, T, Traits &gt;::find_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the key <code>val</code> using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#cds_nonintrusive_EllenBinTreeMap_find_cfunc">find(K const&amp;, Func)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the map. </p>

</div>
</div>
<a class="anchor" id="a5fd250d83d6c2d4f85b7f57cae6073b2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html">cds::container::EllenBinTreeMap</a>&lt; GC, Key, T, Traits &gt;::find_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the key <code>val</code> using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#cds_nonintrusive_EllenBinTreeMap_find_val">find(K const&amp;)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the map. </p>

</div>
</div>
<a class="anchor" id="a5542c4c3d6cd0e8e489722b6ffb154e3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html">cds::container::EllenBinTreeMap</a>&lt; GC, Key, T, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node with key and default value. </p>
<p>The function creates a node with <code>key</code> and default value, and then inserts the node created into the map.</p>
<p>Preconditions:</p>
<ul>
<li>The <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#a108822eb86b7fad23777e9e1894cbb56">key_type</a> should be constructible from a value of type <code>K</code>. In trivial case, <code>K</code> is equal to <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#a108822eb86b7fad23777e9e1894cbb56">key_type</a>.</li>
<li>The <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#a0ef5c676743c86c13332bec26a846412">mapped_type</a> should be default-constructible.</li>
</ul>
<p>Returns <code>true</code> if inserting successful, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a0bc696cff7de22cfaf89c837bb91433f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html">cds::container::EllenBinTreeMap</a>&lt; GC, Key, T, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">K const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V const &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node. </p>
<p>The function creates a node with copy of <code>val</code> value and then inserts the node created into the map.</p>
<p>Preconditions:</p>
<ul>
<li>The <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#a108822eb86b7fad23777e9e1894cbb56">key_type</a> should be constructible from <code>key</code> of type <code>K</code>.</li>
<li>The <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#a4765b80ba2ebc7d640523066ace98076">value_type</a> should be constructible from <code>val</code> of type <code>V</code>.</li>
</ul>
<p>Returns <code>true</code> if <code>val</code> is inserted into the map, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a3a0f2cb50593936ae632b260860202bb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename K , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_map.html">cds::container::EllenBinTreeMap</a>&lt; GC, Key, T, Traits &gt;::insert_key </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node and initialize it by a functor. </p>
<p>This function inserts new node with key <code>key</code> and if inserting is successful then it calls <code>func</code> functor with signature </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1container_1_1_ellen_bin_tree_map.html#a4765b80ba2ebc7d640523066ace98076">value_type</a>&amp; item )  ;</div>
<div class="line">};</div>
</div><!-- fragment --><p>The argument <code>item</code> of user-defined functor <code>func</code> is the reference to the map's item inserted:</p>
<ul>
<li><code>item.first</code> is a const reference to item's key that cannot be changed.</li>
<li><code>item.second</code> is a reference to item's value that may be changed.</li>
</ul>
<p>The user-defined functor can be passed by reference using <code>boost::ref</code> and it is called only if inserting is successful.</p>
<p>The key_type should be constructible from value of type <code>K</code>.</p>
<p>The function allows to split creating of new item into two part:</p>
<ul>
<li>create item from <code>key</code>;</li>
<li>insert new item into the map;</li>
<li>if inserting is successful, initialize the value of item by calling <code>func</code> functor</li>
</ul>
<p>This can be useful if complete initialization of object of <code>value_type</code> is heavyweight and it is preferable that the initialization should be completed only if inserting is successful. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>cds/container/ellen_bintree_map_impl.h</li>
</ul>
</div><!-- contents -->
		<hr/>
		<div align="right">
			<b>cds</b> <b>1.5.0</b> 
			Developed by <i>Maxim Khiszinsky aka khizmax</i> 2007 - 2012
			<br/>
			<i>Autogenerated Sat Dec 28 2013 15:04:02 by Doxygen 1.8.5</i>
		</div>
	</BODY>
</HTML>
