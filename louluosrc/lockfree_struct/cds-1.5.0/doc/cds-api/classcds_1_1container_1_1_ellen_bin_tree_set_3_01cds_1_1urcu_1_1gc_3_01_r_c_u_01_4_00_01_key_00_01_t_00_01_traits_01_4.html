<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>cds: cds::container::EllenBinTreeSet&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">cds
   &#160;<span id="projectnumber">1.5.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecds.html">cds</a></li><li class="navelem"><a class="el" href="namespacecds_1_1container.html">container</a></li><li class="navelem"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html">EllenBinTreeSet< cds::urcu::gc< RCU >, Key, T, Traits ></a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">cds::container::EllenBinTreeSet&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__cds__nonintrusive__set.html">Set</a> &#124; <a class="el" href="group__cds__nonintrusive__tree.html">Tree</a> &#124; <a class="el" href="group__cds__nonintrusive__priority__queue.html">Priority queue</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Set based on Ellen's et al binary search tree (RCU specialization)  
 <a href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#details">More...</a></p>

<p><code>#include &lt;cds/container/ellen_bintree_set_rcu.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cds::container::EllenBinTreeSet&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.png" usemap="#cds::container::EllenBinTreeSet&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;_map" alt=""/>
  <map id="cds::container::EllenBinTreeSet&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;_map" name="cds::container::EllenBinTreeSet&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;_map">
<area href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html" title="Ellen&#39;s et al binary search tree (RCU specialization) " alt="cds::intrusive::EllenBinTree&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;" shape="rect" coords="0,0,419,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a770ec3ab93015a408b07f48c0e238581"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a770ec3ab93015a408b07f48c0e238581"></a>
typedef cds::urcu::gc&lt; RCU &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a770ec3ab93015a408b07f48c0e238581">gc</a></td></tr>
<tr class="memdesc:a770ec3ab93015a408b07f48c0e238581"><td class="mdescLeft">&#160;</td><td class="mdescRight">RCU Garbage collector. <br/></td></tr>
<tr class="separator:a770ec3ab93015a408b07f48c0e238581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae302d7c98cbfb3c5cf5d4c1cc227be15"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae302d7c98cbfb3c5cf5d4c1cc227be15"></a>
typedef Key&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ae302d7c98cbfb3c5cf5d4c1cc227be15">key_type</a></td></tr>
<tr class="memdesc:ae302d7c98cbfb3c5cf5d4c1cc227be15"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of a key stored in internal nodes; key is a part of <code>value_type</code> <br/></td></tr>
<tr class="separator:ae302d7c98cbfb3c5cf5d4c1cc227be15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17765b612bf9d824ad7b5408e8aa40bb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a17765b612bf9d824ad7b5408e8aa40bb"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a17765b612bf9d824ad7b5408e8aa40bb">value_type</a></td></tr>
<tr class="memdesc:a17765b612bf9d824ad7b5408e8aa40bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of value stored in the binary tree <br/></td></tr>
<tr class="separator:a17765b612bf9d824ad7b5408e8aa40bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25acb8df9bdf1adb08bbb504a1b07740"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a25acb8df9bdf1adb08bbb504a1b07740"></a>
typedef Traits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a25acb8df9bdf1adb08bbb504a1b07740">options</a></td></tr>
<tr class="memdesc:a25acb8df9bdf1adb08bbb504a1b07740"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits template parameter. <br/></td></tr>
<tr class="separator:a25acb8df9bdf1adb08bbb504a1b07740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc8bef3a76314922697bce3917b3cd58"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acc8bef3a76314922697bce3917b3cd58"></a>
typedef implementation_defined&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#acc8bef3a76314922697bce3917b3cd58">key_comparator</a></td></tr>
<tr class="memdesc:acc8bef3a76314922697bce3917b3cd58"><td class="mdescLeft">&#160;</td><td class="mdescRight">key compare functor based on <a class="el" href="structcds_1_1opt_1_1compare.html" title="[type-option] Option setter for key comparing ">opt::compare</a> and <a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate ">opt::less</a> option setter. <br/></td></tr>
<tr class="separator:acc8bef3a76314922697bce3917b3cd58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a255b3f6921481a562433a1a8674a6719"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a255b3f6921481a562433a1a8674a6719"></a>
typedef base_class::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a255b3f6921481a562433a1a8674a6719">item_counter</a></td></tr>
<tr class="memdesc:a255b3f6921481a562433a1a8674a6719"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counting policy used. <br/></td></tr>
<tr class="separator:a255b3f6921481a562433a1a8674a6719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b46800359a480bdc217d98216c3b705"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b46800359a480bdc217d98216c3b705"></a>
typedef base_class::memory_model&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a0b46800359a480bdc217d98216c3b705">memory_model</a></td></tr>
<tr class="memdesc:a0b46800359a480bdc217d98216c3b705"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory ordering. See <a class="el" href="structcds_1_1opt_1_1memory__model.html" title="[type-option] Option setter for C++ memory model ">cds::opt::memory_model</a> option. <br/></td></tr>
<tr class="separator:a0b46800359a480bdc217d98216c3b705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22775a7b8d39c3a2f9c822c06d4431cb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a22775a7b8d39c3a2f9c822c06d4431cb"></a>
typedef base_class::stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a22775a7b8d39c3a2f9c822c06d4431cb">stat</a></td></tr>
<tr class="memdesc:a22775a7b8d39c3a2f9c822c06d4431cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal statistics type <br/></td></tr>
<tr class="separator:a22775a7b8d39c3a2f9c822c06d4431cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a5e4e39fdbeb67f38d8fa518cef5083"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a5e4e39fdbeb67f38d8fa518cef5083"></a>
typedef <br class="typebreak"/>
base_class::rcu_check_deadlock&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a7a5e4e39fdbeb67f38d8fa518cef5083">rcu_check_deadlock</a></td></tr>
<tr class="memdesc:a7a5e4e39fdbeb67f38d8fa518cef5083"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deadlock checking policy. <br/></td></tr>
<tr class="separator:a7a5e4e39fdbeb67f38d8fa518cef5083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf8ffece72c5181e330d3758a2a52e33"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf8ffece72c5181e330d3758a2a52e33"></a>
typedef options::key_extractor&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#aaf8ffece72c5181e330d3758a2a52e33">key_extractor</a></td></tr>
<tr class="memdesc:aaf8ffece72c5181e330d3758a2a52e33"><td class="mdescLeft">&#160;</td><td class="mdescRight">key extracting functor <br/></td></tr>
<tr class="separator:aaf8ffece72c5181e330d3758a2a52e33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b725d4a00f42cb24332475879669416"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b725d4a00f42cb24332475879669416"></a>
typedef options::allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a6b725d4a00f42cb24332475879669416">allocator_type</a></td></tr>
<tr class="memdesc:a6b725d4a00f42cb24332475879669416"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator for leaf nodes. <br/></td></tr>
<tr class="separator:a6b725d4a00f42cb24332475879669416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc5e20baa703ef039783467581d9b542"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afc5e20baa703ef039783467581d9b542"></a>
typedef base_class::node_allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#afc5e20baa703ef039783467581d9b542">node_allocator</a></td></tr>
<tr class="memdesc:afc5e20baa703ef039783467581d9b542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal node allocator. <br/></td></tr>
<tr class="separator:afc5e20baa703ef039783467581d9b542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a498fc363912ef04419d0cd009234f59b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a498fc363912ef04419d0cd009234f59b"></a>
typedef <br class="typebreak"/>
base_class::update_desc_allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a498fc363912ef04419d0cd009234f59b">update_desc_allocator</a></td></tr>
<tr class="memdesc:a498fc363912ef04419d0cd009234f59b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update descriptor allocator. <br/></td></tr>
<tr class="separator:a498fc363912ef04419d0cd009234f59b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html">cds::intrusive::EllenBinTree&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;</a></td></tr>
<tr class="memitem:a1c077a01c42f58242a9a8534e503ca0e inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c077a01c42f58242a9a8534e503ca0e"></a>
typedef cds::urcu::gc&lt; RCU &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a1c077a01c42f58242a9a8534e503ca0e">gc</a></td></tr>
<tr class="memdesc:a1c077a01c42f58242a9a8534e503ca0e inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">RCU Garbage collector. <br/></td></tr>
<tr class="separator:a1c077a01c42f58242a9a8534e503ca0e inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c6b62e5002f389473533d0d8e185da inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af5c6b62e5002f389473533d0d8e185da"></a>
typedef Key&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#af5c6b62e5002f389473533d0d8e185da">key_type</a></td></tr>
<tr class="memdesc:af5c6b62e5002f389473533d0d8e185da inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of a key stored in internal nodes; key is a part of <code>value_type</code> <br/></td></tr>
<tr class="separator:af5c6b62e5002f389473533d0d8e185da inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add56a738dd647d7d4afee42ba853cd49 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add56a738dd647d7d4afee42ba853cd49"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#add56a738dd647d7d4afee42ba853cd49">value_type</a></td></tr>
<tr class="memdesc:add56a738dd647d7d4afee42ba853cd49 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of value stored in the binary tree <br/></td></tr>
<tr class="separator:add56a738dd647d7d4afee42ba853cd49 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79638e8405e79af1e03575530920d8f6 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a79638e8405e79af1e03575530920d8f6"></a>
typedef Traits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a79638e8405e79af1e03575530920d8f6">options</a></td></tr>
<tr class="memdesc:a79638e8405e79af1e03575530920d8f6 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits template parameter. <br/></td></tr>
<tr class="separator:a79638e8405e79af1e03575530920d8f6 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b2ef016fe17338a78c96ea164b66598 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b2ef016fe17338a78c96ea164b66598"></a>
typedef options::hook&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a3b2ef016fe17338a78c96ea164b66598">hook</a></td></tr>
<tr class="memdesc:a3b2ef016fe17338a78c96ea164b66598 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">hook type <br/></td></tr>
<tr class="separator:a3b2ef016fe17338a78c96ea164b66598 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2a32ff430f6656f931a19abc62559f0 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac2a32ff430f6656f931a19abc62559f0"></a>
typedef hook::node_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ac2a32ff430f6656f931a19abc62559f0">node_type</a></td></tr>
<tr class="memdesc:ac2a32ff430f6656f931a19abc62559f0 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">node type <br/></td></tr>
<tr class="separator:ac2a32ff430f6656f931a19abc62559f0 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4c742b3e71e3e6f8c18088a94be9e8 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc4c742b3e71e3e6f8c18088a94be9e8"></a>
typedef options::disposer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#abc4c742b3e71e3e6f8c18088a94be9e8">disposer</a></td></tr>
<tr class="memdesc:abc4c742b3e71e3e6f8c18088a94be9e8 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">leaf node disposer <br/></td></tr>
<tr class="separator:abc4c742b3e71e3e6f8c18088a94be9e8 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcbe0005ae2be7aba4142ad27517220e inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adcbe0005ae2be7aba4142ad27517220e"></a>
typedef implementation_defined&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#adcbe0005ae2be7aba4142ad27517220e">key_comparator</a></td></tr>
<tr class="memdesc:adcbe0005ae2be7aba4142ad27517220e inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">key compare functor based on <a class="el" href="structcds_1_1opt_1_1compare.html" title="[type-option] Option setter for key comparing ">opt::compare</a> and <a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate ">opt::less</a> option setter. <br/></td></tr>
<tr class="separator:adcbe0005ae2be7aba4142ad27517220e inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a731dd06317b60f47d72a6589e9aad44b inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a731dd06317b60f47d72a6589e9aad44b"></a>
typedef <a class="el" href="structcds_1_1intrusive_1_1get__node__traits.html">get_node_traits</a><br class="typebreak"/>
&lt; <a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#add56a738dd647d7d4afee42ba853cd49">value_type</a>, <a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ac2a32ff430f6656f931a19abc62559f0">node_type</a>, <a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a3b2ef016fe17338a78c96ea164b66598">hook</a> &gt;<br class="typebreak"/>
::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a731dd06317b60f47d72a6589e9aad44b">node_traits</a></td></tr>
<tr class="memdesc:a731dd06317b60f47d72a6589e9aad44b inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node traits. <br/></td></tr>
<tr class="separator:a731dd06317b60f47d72a6589e9aad44b inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf5e22a713d77a11d5ae1bf80377b4d9 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf5e22a713d77a11d5ae1bf80377b4d9"></a>
typedef options::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#abf5e22a713d77a11d5ae1bf80377b4d9">item_counter</a></td></tr>
<tr class="memdesc:abf5e22a713d77a11d5ae1bf80377b4d9 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counting policy used. <br/></td></tr>
<tr class="separator:abf5e22a713d77a11d5ae1bf80377b4d9 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61d66cd9eeed39412078763b0dc362c4 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a61d66cd9eeed39412078763b0dc362c4"></a>
typedef options::memory_model&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a61d66cd9eeed39412078763b0dc362c4">memory_model</a></td></tr>
<tr class="memdesc:a61d66cd9eeed39412078763b0dc362c4 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory ordering. See <a class="el" href="structcds_1_1opt_1_1memory__model.html" title="[type-option] Option setter for C++ memory model ">cds::opt::memory_model</a> option. <br/></td></tr>
<tr class="separator:a61d66cd9eeed39412078763b0dc362c4 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1aa9f8188ea6d8a45aaf8d22a712173 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1aa9f8188ea6d8a45aaf8d22a712173"></a>
typedef options::stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#af1aa9f8188ea6d8a45aaf8d22a712173">stat</a></td></tr>
<tr class="memdesc:af1aa9f8188ea6d8a45aaf8d22a712173 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal statistics type <br/></td></tr>
<tr class="separator:af1aa9f8188ea6d8a45aaf8d22a712173 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a689e3dbc45e816fe171a995c46b1a296 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a689e3dbc45e816fe171a995c46b1a296"></a>
typedef options::rcu_check_deadlock&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a689e3dbc45e816fe171a995c46b1a296">rcu_check_deadlock</a></td></tr>
<tr class="memdesc:a689e3dbc45e816fe171a995c46b1a296 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deadlock checking policy. <br/></td></tr>
<tr class="separator:a689e3dbc45e816fe171a995c46b1a296 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a679e8232c324483ed90fcb4ae3c7edb5 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a679e8232c324483ed90fcb4ae3c7edb5"></a>
typedef options::key_extractor&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a679e8232c324483ed90fcb4ae3c7edb5">key_extractor</a></td></tr>
<tr class="memdesc:a679e8232c324483ed90fcb4ae3c7edb5 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">key extracting functor <br/></td></tr>
<tr class="separator:a679e8232c324483ed90fcb4ae3c7edb5 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23d555320e46b05bfabea6db60e0fa62 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a23d555320e46b05bfabea6db60e0fa62"></a>
typedef options::node_allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a23d555320e46b05bfabea6db60e0fa62">node_allocator</a></td></tr>
<tr class="memdesc:a23d555320e46b05bfabea6db60e0fa62 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal node allocator. <br/></td></tr>
<tr class="separator:a23d555320e46b05bfabea6db60e0fa62 inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a779c248a32902476f7860e94910efaef inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a779c248a32902476f7860e94910efaef"></a>
typedef <br class="typebreak"/>
options::update_desc_allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a779c248a32902476f7860e94910efaef">update_desc_allocator</a></td></tr>
<tr class="memdesc:a779c248a32902476f7860e94910efaef inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update descriptor allocator. <br/></td></tr>
<tr class="separator:a779c248a32902476f7860e94910efaef inherit pub_types_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae480ead0790e81304cb611750461a2f9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae480ead0790e81304cb611750461a2f9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ae480ead0790e81304cb611750461a2f9">EllenBinTreeSet</a> ()</td></tr>
<tr class="memdesc:ae480ead0790e81304cb611750461a2f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br/></td></tr>
<tr class="separator:ae480ead0790e81304cb611750461a2f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9600315ec5b2be04134d4f5c21a6fb20"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9600315ec5b2be04134d4f5c21a6fb20"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a9600315ec5b2be04134d4f5c21a6fb20">~EllenBinTreeSet</a> ()</td></tr>
<tr class="memdesc:a9600315ec5b2be04134d4f5c21a6fb20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the set. <br/></td></tr>
<tr class="separator:a9600315ec5b2be04134d4f5c21a6fb20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a247d812b16ef0d80721152d7917dbb40"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:a247d812b16ef0d80721152d7917dbb40"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a247d812b16ef0d80721152d7917dbb40">insert</a> (Q const &amp;val)</td></tr>
<tr class="memdesc:a247d812b16ef0d80721152d7917dbb40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a247d812b16ef0d80721152d7917dbb40">More...</a><br/></td></tr>
<tr class="separator:a247d812b16ef0d80721152d7917dbb40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f13e865f9b3ede54a81ecd7299e5168"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:a0f13e865f9b3ede54a81ecd7299e5168"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a0f13e865f9b3ede54a81ecd7299e5168">insert</a> (Q const &amp;val, Func f)</td></tr>
<tr class="memdesc:a0f13e865f9b3ede54a81ecd7299e5168"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a0f13e865f9b3ede54a81ecd7299e5168">More...</a><br/></td></tr>
<tr class="separator:a0f13e865f9b3ede54a81ecd7299e5168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8948039ed91e1ed4fbe6bcd0e8fc1d3d"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:a8948039ed91e1ed4fbe6bcd0e8fc1d3d"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a8948039ed91e1ed4fbe6bcd0e8fc1d3d">ensure</a> (const Q &amp;val, Func func)</td></tr>
<tr class="memdesc:a8948039ed91e1ed4fbe6bcd0e8fc1d3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that the item exists in the set.  <a href="#a8948039ed91e1ed4fbe6bcd0e8fc1d3d">More...</a><br/></td></tr>
<tr class="separator:a8948039ed91e1ed4fbe6bcd0e8fc1d3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd6718e5942f8f0b0ade3cf9ab730b1"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a7cd6718e5942f8f0b0ade3cf9ab730b1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a7cd6718e5942f8f0b0ade3cf9ab730b1">emplace</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a7cd6718e5942f8f0b0ade3cf9ab730b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts data of type <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a17765b612bf9d824ad7b5408e8aa40bb">value_type</a> constructed with <code>std::forward&lt;Args&gt;(args)...</code>  <a href="#a7cd6718e5942f8f0b0ade3cf9ab730b1">More...</a><br/></td></tr>
<tr class="separator:a7cd6718e5942f8f0b0ade3cf9ab730b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabe916710687a8ffb333f79b3128ba09"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:aabe916710687a8ffb333f79b3128ba09"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#aabe916710687a8ffb333f79b3128ba09">erase</a> (Q const &amp;key)</td></tr>
<tr class="memdesc:aabe916710687a8ffb333f79b3128ba09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete <code>key</code> from the set.  <a href="#aabe916710687a8ffb333f79b3128ba09">More...</a><br/></td></tr>
<tr class="separator:aabe916710687a8ffb333f79b3128ba09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4dee540ea9a589af75496c5ecc5e0c7"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less &gt; </td></tr>
<tr class="memitem:ae4dee540ea9a589af75496c5ecc5e0c7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ae4dee540ea9a589af75496c5ecc5e0c7">erase_with</a> (Q const &amp;key, Less pred)</td></tr>
<tr class="memdesc:ae4dee540ea9a589af75496c5ecc5e0c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set using <code>pred</code> predicate for searching.  <a href="#ae4dee540ea9a589af75496c5ecc5e0c7">More...</a><br/></td></tr>
<tr class="separator:ae4dee540ea9a589af75496c5ecc5e0c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5d79aa56cf05370278f2defb9594b90"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:aa5d79aa56cf05370278f2defb9594b90"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#aa5d79aa56cf05370278f2defb9594b90">erase</a> (Q const &amp;key, Func f)</td></tr>
<tr class="memdesc:aa5d79aa56cf05370278f2defb9594b90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete <code>key</code> from the set.  <a href="#aa5d79aa56cf05370278f2defb9594b90">More...</a><br/></td></tr>
<tr class="separator:aa5d79aa56cf05370278f2defb9594b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a541d19627182f19187d6cec90363f565"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:a541d19627182f19187d6cec90363f565"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a541d19627182f19187d6cec90363f565">erase_with</a> (Q const &amp;key, Less pred, Func f)</td></tr>
<tr class="memdesc:a541d19627182f19187d6cec90363f565"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set using <code>pred</code> predicate for searching.  <a href="#a541d19627182f19187d6cec90363f565">More...</a><br/></td></tr>
<tr class="separator:a541d19627182f19187d6cec90363f565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40f7d499a57854052426e98baf0a1935"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a40f7d499a57854052426e98baf0a1935">extract_min</a> (<a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a17765b612bf9d824ad7b5408e8aa40bb">value_type</a> &amp;dest)</td></tr>
<tr class="memdesc:a40f7d499a57854052426e98baf0a1935"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an item with minimal key from the set.  <a href="#a40f7d499a57854052426e98baf0a1935">More...</a><br/></td></tr>
<tr class="separator:a40f7d499a57854052426e98baf0a1935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18aaa14bbc8ba94175873d39384d1459"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:a18aaa14bbc8ba94175873d39384d1459"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a18aaa14bbc8ba94175873d39384d1459">extract_min</a> (Q &amp;dest, Func f)</td></tr>
<tr class="memdesc:a18aaa14bbc8ba94175873d39384d1459"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an item with minimal key from the set.  <a href="#a18aaa14bbc8ba94175873d39384d1459">More...</a><br/></td></tr>
<tr class="separator:a18aaa14bbc8ba94175873d39384d1459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabbd48c190391566738580f0ab9d57c5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#aabbd48c190391566738580f0ab9d57c5">extract_max</a> (<a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a17765b612bf9d824ad7b5408e8aa40bb">value_type</a> &amp;dest)</td></tr>
<tr class="memdesc:aabbd48c190391566738580f0ab9d57c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an item with maximal key from the set.  <a href="#aabbd48c190391566738580f0ab9d57c5">More...</a><br/></td></tr>
<tr class="separator:aabbd48c190391566738580f0ab9d57c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b0f714441431bff46adcbccbfa963e6"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:a7b0f714441431bff46adcbccbfa963e6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a7b0f714441431bff46adcbccbfa963e6">extract_max</a> (Q &amp;dest, Func f)</td></tr>
<tr class="memdesc:a7b0f714441431bff46adcbccbfa963e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an item with maximal key from the set.  <a href="#a7b0f714441431bff46adcbccbfa963e6">More...</a><br/></td></tr>
<tr class="separator:a7b0f714441431bff46adcbccbfa963e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aa17ccda5d27ea648109d063eea9a7f"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:a2aa17ccda5d27ea648109d063eea9a7f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a2aa17ccda5d27ea648109d063eea9a7f">find</a> (Q &amp;val, Func f)</td></tr>
<tr class="memdesc:a2aa17ccda5d27ea648109d063eea9a7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code>.  <a href="#a2aa17ccda5d27ea648109d063eea9a7f">More...</a><br/></td></tr>
<tr class="separator:a2aa17ccda5d27ea648109d063eea9a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae35ad36ab80db2ec9ec06d66871dccfe"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:ae35ad36ab80db2ec9ec06d66871dccfe"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ae35ad36ab80db2ec9ec06d66871dccfe">find_with</a> (Q &amp;val, Less pred, Func f)</td></tr>
<tr class="memdesc:ae35ad36ab80db2ec9ec06d66871dccfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code> using <code>pred</code> predicate for searching.  <a href="#ae35ad36ab80db2ec9ec06d66871dccfe">More...</a><br/></td></tr>
<tr class="separator:ae35ad36ab80db2ec9ec06d66871dccfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50e3a875583aff66423bc40df8f268d3"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:a50e3a875583aff66423bc40df8f268d3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a50e3a875583aff66423bc40df8f268d3">find</a> (Q const &amp;val, Func f)</td></tr>
<tr class="memdesc:a50e3a875583aff66423bc40df8f268d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code>.  <a href="#a50e3a875583aff66423bc40df8f268d3">More...</a><br/></td></tr>
<tr class="separator:a50e3a875583aff66423bc40df8f268d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187eadb318bb65cf3b978d9322ab45b1"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:a187eadb318bb65cf3b978d9322ab45b1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a187eadb318bb65cf3b978d9322ab45b1">find_with</a> (Q const &amp;val, Less pred, Func f)</td></tr>
<tr class="memdesc:a187eadb318bb65cf3b978d9322ab45b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code> using <code>pred</code> predicate for searching.  <a href="#a187eadb318bb65cf3b978d9322ab45b1">More...</a><br/></td></tr>
<tr class="separator:a187eadb318bb65cf3b978d9322ab45b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fc3ec7ae35a1f71b2763db660c007e1"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:a5fc3ec7ae35a1f71b2763db660c007e1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a5fc3ec7ae35a1f71b2763db660c007e1">find</a> (Q const &amp;val)</td></tr>
<tr class="memdesc:a5fc3ec7ae35a1f71b2763db660c007e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key <code>val</code>.  <a href="#a5fc3ec7ae35a1f71b2763db660c007e1">More...</a><br/></td></tr>
<tr class="separator:a5fc3ec7ae35a1f71b2763db660c007e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c11cf2779637e38558bb999720c18e7"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less &gt; </td></tr>
<tr class="memitem:a6c11cf2779637e38558bb999720c18e7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a6c11cf2779637e38558bb999720c18e7">find_with</a> (Q const &amp;val, Less pred)</td></tr>
<tr class="memdesc:a6c11cf2779637e38558bb999720c18e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code> using <code>pred</code> predicate for searching.  <a href="#a6c11cf2779637e38558bb999720c18e7">More...</a><br/></td></tr>
<tr class="separator:a6c11cf2779637e38558bb999720c18e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6441448b0697b4a01e45a9c541166526"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a6441448b0697b4a01e45a9c541166526">clear</a> ()</td></tr>
<tr class="memdesc:a6441448b0697b4a01e45a9c541166526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the set (non-atomic)  <a href="#a6441448b0697b4a01e45a9c541166526">More...</a><br/></td></tr>
<tr class="separator:a6441448b0697b4a01e45a9c541166526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04e7c1113b331c49abb77ce011bb4e90"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a04e7c1113b331c49abb77ce011bb4e90"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a04e7c1113b331c49abb77ce011bb4e90">empty</a> () const </td></tr>
<tr class="memdesc:a04e7c1113b331c49abb77ce011bb4e90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the set is empty. <br/></td></tr>
<tr class="separator:a04e7c1113b331c49abb77ce011bb4e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a141ba970f7bea87401c9bcf307309bf6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a141ba970f7bea87401c9bcf307309bf6">size</a> () const </td></tr>
<tr class="memdesc:a141ba970f7bea87401c9bcf307309bf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns item count in the set.  <a href="#a141ba970f7bea87401c9bcf307309bf6">More...</a><br/></td></tr>
<tr class="separator:a141ba970f7bea87401c9bcf307309bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65d1c9c9548bc5768dcb15c57032be18"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a65d1c9c9548bc5768dcb15c57032be18"></a>
<a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a22775a7b8d39c3a2f9c822c06d4431cb">stat</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a65d1c9c9548bc5768dcb15c57032be18">statistics</a> () const </td></tr>
<tr class="memdesc:a65d1c9c9548bc5768dcb15c57032be18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const reference to internal statistics. <br/></td></tr>
<tr class="separator:a65d1c9c9548bc5768dcb15c57032be18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbbbd5e33b6f10b8cae39096bdcf36b9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#abbbbd5e33b6f10b8cae39096bdcf36b9">check_consistency</a> () const </td></tr>
<tr class="memdesc:abbbbd5e33b6f10b8cae39096bdcf36b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks internal consistency (not atomic, not thread-safe)  <a href="#abbbbd5e33b6f10b8cae39096bdcf36b9">More...</a><br/></td></tr>
<tr class="separator:abbbbd5e33b6f10b8cae39096bdcf36b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html">cds::intrusive::EllenBinTree&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;</a></td></tr>
<tr class="memitem:aad038f808e1c52cba16bd09c044ae9a0 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad038f808e1c52cba16bd09c044ae9a0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#aad038f808e1c52cba16bd09c044ae9a0">EllenBinTree</a> ()</td></tr>
<tr class="memdesc:aad038f808e1c52cba16bd09c044ae9a0 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br/></td></tr>
<tr class="separator:aad038f808e1c52cba16bd09c044ae9a0 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce6aaf0ca14b0731c0db3a61e7d4012 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ce6aaf0ca14b0731c0db3a61e7d4012"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a6ce6aaf0ca14b0731c0db3a61e7d4012">~EllenBinTree</a> ()</td></tr>
<tr class="memdesc:a6ce6aaf0ca14b0731c0db3a61e7d4012 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the tree. <br/></td></tr>
<tr class="separator:a6ce6aaf0ca14b0731c0db3a61e7d4012 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02172bcb0d7173db7c6eae9967a1fa28 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a02172bcb0d7173db7c6eae9967a1fa28">insert</a> (<a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#add56a738dd647d7d4afee42ba853cd49">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:a02172bcb0d7173db7c6eae9967a1fa28 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a02172bcb0d7173db7c6eae9967a1fa28">More...</a><br/></td></tr>
<tr class="separator:a02172bcb0d7173db7c6eae9967a1fa28 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a720938b154f0d19179a7a92610ed459b inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:a720938b154f0d19179a7a92610ed459b inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a720938b154f0d19179a7a92610ed459b">insert</a> (<a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#add56a738dd647d7d4afee42ba853cd49">value_type</a> &amp;val, Func f)</td></tr>
<tr class="memdesc:a720938b154f0d19179a7a92610ed459b inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node.  <a href="#a720938b154f0d19179a7a92610ed459b">More...</a><br/></td></tr>
<tr class="separator:a720938b154f0d19179a7a92610ed459b inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96086eb88ec0537a00c69f2c3173489e inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:a96086eb88ec0537a00c69f2c3173489e inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a96086eb88ec0537a00c69f2c3173489e">ensure</a> (<a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#add56a738dd647d7d4afee42ba853cd49">value_type</a> &amp;val, Func func)</td></tr>
<tr class="memdesc:a96086eb88ec0537a00c69f2c3173489e inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that the <code>val</code> exists in the tree.  <a href="#a96086eb88ec0537a00c69f2c3173489e">More...</a><br/></td></tr>
<tr class="separator:a96086eb88ec0537a00c69f2c3173489e inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a973e6bffddd1f5edf3e35729d7d031a4 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a973e6bffddd1f5edf3e35729d7d031a4">unlink</a> (<a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#add56a738dd647d7d4afee42ba853cd49">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:a973e6bffddd1f5edf3e35729d7d031a4 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlinks the item <code>val</code> from the tree.  <a href="#a973e6bffddd1f5edf3e35729d7d031a4">More...</a><br/></td></tr>
<tr class="separator:a973e6bffddd1f5edf3e35729d7d031a4 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28bdeb008cdbe8fc85f7350a86a734fd inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:a28bdeb008cdbe8fc85f7350a86a734fd inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a28bdeb008cdbe8fc85f7350a86a734fd">erase</a> (const Q &amp;val)</td></tr>
<tr class="memdesc:a28bdeb008cdbe8fc85f7350a86a734fd inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the tree.  <a href="#a28bdeb008cdbe8fc85f7350a86a734fd">More...</a><br/></td></tr>
<tr class="separator:a28bdeb008cdbe8fc85f7350a86a734fd inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2139489e597ce28bdeb551a154fd67c2 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less &gt; </td></tr>
<tr class="memitem:a2139489e597ce28bdeb551a154fd67c2 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a2139489e597ce28bdeb551a154fd67c2">erase_with</a> (const Q &amp;val, Less pred)</td></tr>
<tr class="memdesc:a2139489e597ce28bdeb551a154fd67c2 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the item from the tree with comparing functor <code>pred</code>.  <a href="#a2139489e597ce28bdeb551a154fd67c2">More...</a><br/></td></tr>
<tr class="separator:a2139489e597ce28bdeb551a154fd67c2 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae320a229094d5925b446aa6602222906 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:ae320a229094d5925b446aa6602222906 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ae320a229094d5925b446aa6602222906">erase</a> (Q const &amp;val, Func f)</td></tr>
<tr class="memdesc:ae320a229094d5925b446aa6602222906 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the tree.  <a href="#ae320a229094d5925b446aa6602222906">More...</a><br/></td></tr>
<tr class="separator:ae320a229094d5925b446aa6602222906 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca62084ba8240726a0135c4cea7927ea inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:aca62084ba8240726a0135c4cea7927ea inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#aca62084ba8240726a0135c4cea7927ea">erase_with</a> (Q const &amp;val, Less pred, Func f)</td></tr>
<tr class="memdesc:aca62084ba8240726a0135c4cea7927ea inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the item from the tree with comparing functor <code>pred</code>.  <a href="#aca62084ba8240726a0135c4cea7927ea">More...</a><br/></td></tr>
<tr class="separator:aca62084ba8240726a0135c4cea7927ea inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a475d6c5b83df7def3176ec1fe0c7bf04 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#add56a738dd647d7d4afee42ba853cd49">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a475d6c5b83df7def3176ec1fe0c7bf04">extract_min</a> ()</td></tr>
<tr class="memdesc:a475d6c5b83df7def3176ec1fe0c7bf04 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an item with minimal key from the tree.  <a href="#a475d6c5b83df7def3176ec1fe0c7bf04">More...</a><br/></td></tr>
<tr class="separator:a475d6c5b83df7def3176ec1fe0c7bf04 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cb88ea9ab8737d8241c7464973078a4 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#add56a738dd647d7d4afee42ba853cd49">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a0cb88ea9ab8737d8241c7464973078a4">extract_max</a> ()</td></tr>
<tr class="memdesc:a0cb88ea9ab8737d8241c7464973078a4 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an item with maximal key from the tree.  <a href="#a0cb88ea9ab8737d8241c7464973078a4">More...</a><br/></td></tr>
<tr class="separator:a0cb88ea9ab8737d8241c7464973078a4 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace8ee44a408dc41ac55c59e508e5d975 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:ace8ee44a408dc41ac55c59e508e5d975 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#add56a738dd647d7d4afee42ba853cd49">value_type</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ace8ee44a408dc41ac55c59e508e5d975">extract</a> (Q const &amp;val)</td></tr>
<tr class="memdesc:ace8ee44a408dc41ac55c59e508e5d975 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an item from the tree.  <a href="#ace8ee44a408dc41ac55c59e508e5d975">More...</a><br/></td></tr>
<tr class="separator:ace8ee44a408dc41ac55c59e508e5d975 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69eb5676aa73c10e71b55b2dd8d9e563 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less &gt; </td></tr>
<tr class="memitem:a69eb5676aa73c10e71b55b2dd8d9e563 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#add56a738dd647d7d4afee42ba853cd49">value_type</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a69eb5676aa73c10e71b55b2dd8d9e563">extract_with</a> (Q const &amp;val, Less pred)</td></tr>
<tr class="memdesc:a69eb5676aa73c10e71b55b2dd8d9e563 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an item from the set using <code>pred</code> for searching.  <a href="#a69eb5676aa73c10e71b55b2dd8d9e563">More...</a><br/></td></tr>
<tr class="separator:a69eb5676aa73c10e71b55b2dd8d9e563 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2efa077bde2f8d228ca34695fb18b691 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:a2efa077bde2f8d228ca34695fb18b691 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a2efa077bde2f8d228ca34695fb18b691">find</a> (Q const &amp;val) const </td></tr>
<tr class="memdesc:a2efa077bde2f8d228ca34695fb18b691 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code>.  <a href="#a2efa077bde2f8d228ca34695fb18b691">More...</a><br/></td></tr>
<tr class="separator:a2efa077bde2f8d228ca34695fb18b691 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a1d90aa74177fea20157877ff4a3037 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less &gt; </td></tr>
<tr class="memitem:a3a1d90aa74177fea20157877ff4a3037 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a3a1d90aa74177fea20157877ff4a3037">find_with</a> (Q const &amp;val, Less pred) const </td></tr>
<tr class="memdesc:a3a1d90aa74177fea20157877ff4a3037 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code> with comparing functor <code>pred</code>.  <a href="#a3a1d90aa74177fea20157877ff4a3037">More...</a><br/></td></tr>
<tr class="separator:a3a1d90aa74177fea20157877ff4a3037 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a6ffa668b871e0d173132b3fa596ef9 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:a9a6ffa668b871e0d173132b3fa596ef9 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a9a6ffa668b871e0d173132b3fa596ef9">find</a> (Q &amp;val, Func f) const </td></tr>
<tr class="memdesc:a9a6ffa668b871e0d173132b3fa596ef9 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code>.  <a href="#a9a6ffa668b871e0d173132b3fa596ef9">More...</a><br/></td></tr>
<tr class="separator:a9a6ffa668b871e0d173132b3fa596ef9 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ce3da11463c7408609ffd81c9e77d7 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:a63ce3da11463c7408609ffd81c9e77d7 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a63ce3da11463c7408609ffd81c9e77d7">find_with</a> (Q &amp;val, Less pred, Func f) const </td></tr>
<tr class="memdesc:a63ce3da11463c7408609ffd81c9e77d7 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code> with comparing functor <code>pred</code>.  <a href="#a63ce3da11463c7408609ffd81c9e77d7">More...</a><br/></td></tr>
<tr class="separator:a63ce3da11463c7408609ffd81c9e77d7 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8307e68cbc51a2ca215bb2df33c4041 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Func &gt; </td></tr>
<tr class="memitem:ae8307e68cbc51a2ca215bb2df33c4041 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#ae8307e68cbc51a2ca215bb2df33c4041">find</a> (Q const &amp;val, Func f) const </td></tr>
<tr class="memdesc:ae8307e68cbc51a2ca215bb2df33c4041 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code>.  <a href="#ae8307e68cbc51a2ca215bb2df33c4041">More...</a><br/></td></tr>
<tr class="separator:ae8307e68cbc51a2ca215bb2df33c4041 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af191700f7f5fa0579ab3178aa936e405 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename Less , typename Func &gt; </td></tr>
<tr class="memitem:af191700f7f5fa0579ab3178aa936e405 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#af191700f7f5fa0579ab3178aa936e405">find_with</a> (Q const &amp;val, Less pred, Func f) const </td></tr>
<tr class="memdesc:af191700f7f5fa0579ab3178aa936e405 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the key <code>val</code> with comparing functor <code>pred</code>.  <a href="#af191700f7f5fa0579ab3178aa936e405">More...</a><br/></td></tr>
<tr class="separator:af191700f7f5fa0579ab3178aa936e405 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a229deaa9345b5f9c858f2e05dbf357ce inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a229deaa9345b5f9c858f2e05dbf357ce"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a229deaa9345b5f9c858f2e05dbf357ce">empty</a> () const </td></tr>
<tr class="memdesc:a229deaa9345b5f9c858f2e05dbf357ce inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the tree is empty. <br/></td></tr>
<tr class="separator:a229deaa9345b5f9c858f2e05dbf357ce inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9de3ae3ed073bf0e9b7890551d3d113c inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a9de3ae3ed073bf0e9b7890551d3d113c">clear</a> ()</td></tr>
<tr class="memdesc:a9de3ae3ed073bf0e9b7890551d3d113c inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the tree (non-atomic)  <a href="#a9de3ae3ed073bf0e9b7890551d3d113c">More...</a><br/></td></tr>
<tr class="separator:a9de3ae3ed073bf0e9b7890551d3d113c inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a864f1ab0d1f40d330a1e6815c315482d inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a864f1ab0d1f40d330a1e6815c315482d">size</a> () const </td></tr>
<tr class="memdesc:a864f1ab0d1f40d330a1e6815c315482d inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns item count in the tree.  <a href="#a864f1ab0d1f40d330a1e6815c315482d">More...</a><br/></td></tr>
<tr class="separator:a864f1ab0d1f40d330a1e6815c315482d inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8619c8794b92e04f9115b11af571d446 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8619c8794b92e04f9115b11af571d446"></a>
<a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#af1aa9f8188ea6d8a45aaf8d22a712173">stat</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a8619c8794b92e04f9115b11af571d446">statistics</a> () const </td></tr>
<tr class="memdesc:a8619c8794b92e04f9115b11af571d446 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns const reference to internal statistics. <br/></td></tr>
<tr class="separator:a8619c8794b92e04f9115b11af571d446 inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1caa29830fbf8664dcc3611e23d3ec0a inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a1caa29830fbf8664dcc3611e23d3ec0a">check_consistency</a> () const </td></tr>
<tr class="memdesc:a1caa29830fbf8664dcc3611e23d3ec0a inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks internal consistency (not atomic, not thread-safe)  <a href="#a1caa29830fbf8664dcc3611e23d3ec0a">More...</a><br/></td></tr>
<tr class="separator:a1caa29830fbf8664dcc3611e23d3ec0a inherit pub_methods_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_attribs_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html">cds::intrusive::EllenBinTree&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;</a></td></tr>
<tr class="memitem:a3e7f05c5f6483acbc00aa7ede418730f inherit pro_attribs_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e7f05c5f6483acbc00aa7ede418730f"></a>
<a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#abf5e22a713d77a11d5ae1bf80377b4d9">item_counter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a3e7f05c5f6483acbc00aa7ede418730f">m_ItemCounter</a></td></tr>
<tr class="memdesc:a3e7f05c5f6483acbc00aa7ede418730f inherit pro_attribs_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">item counter <br/></td></tr>
<tr class="separator:a3e7f05c5f6483acbc00aa7ede418730f inherit pro_attribs_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72420a225c0fd08e642748ce756e72c7 inherit pro_attribs_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a72420a225c0fd08e642748ce756e72c7"></a>
<a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#af1aa9f8188ea6d8a45aaf8d22a712173">stat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a72420a225c0fd08e642748ce756e72c7">m_Stat</a></td></tr>
<tr class="memdesc:a72420a225c0fd08e642748ce756e72c7 inherit pro_attribs_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal statistics <br/></td></tr>
<tr class="separator:a72420a225c0fd08e642748ce756e72c7 inherit pro_attribs_classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class RCU, typename Key, typename T, class Traits = ellen_bintree::type_traits&gt;<br/>
class cds::container::EllenBinTreeSet&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;</h3>

<p>Set based on Ellen's et al binary search tree (RCU specialization) </p>
<p><a class="anchor" id="cds_container_EllenBinTreeSet_rcu"></a> Source:</p>
<ul>
<li>[2010] F.Ellen, P.Fatourou, E.Ruppert, F.van Breugel "Non-blocking Binary Search Tree"</li>
</ul>
<p>EllenBinTreeSet is an unbalanced leaf-oriented binary search tree that implements the <em>set</em> abstract data type. Nodes maintains child pointers but not parent pointers. Every internal node has exactly two children, and all data of type <code>T</code> currently in the tree are stored in the leaves. Internal nodes of the tree are used to direct <code>find</code> operation along the path to the correct leaf. The keys (of <code>Key</code> type) stored in internal nodes may or may not be in the set. <code>Key</code> type is a subset of <code>T</code> type. There should be exactly defined a key extracting functor for converting object of type <code>T</code> to object of type <code>Key</code>.</p>
<p>Due to <code>extract_min</code> and <code>extract_max</code> member functions the <code>EllenBinTreeSet</code> can act as a <em>priority queue</em>. In this case you should provide unique compound key, for example, the priority value plus some uniformly distributed random value.</p>
<dl class="section warning"><dt>Warning</dt><dd>Recall the tree is <b>unbalanced</b>. The complexity of operations is <code>O(log N)</code> for uniformly distributed random keys, but in worst case the complexity is <code>O(N)</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>In the current implementation we do not use helping technique described in original paper. So, the current implementation is near to fine-grained lock-based tree. Helping will be implemented in future release</dd></dl>
<p><b>Template arguments</b> :</p>
<ul>
<li><code>RCU</code> - one of <a class="el" href="namespacecds_1_1urcu.html#cds_urcu_gc">RCU type</a></li>
<li><code>Key</code> - key type, a subset of <code>T</code> </li>
<li><code>T</code> - type to be stored in tree's leaf nodes.</li>
<li><code>Traits</code> - type traits. See <a class="el" href="structcds_1_1container_1_1ellen__bintree_1_1type__traits.html" title="Type traits for EllenBinTreeSet, EllenBinTreeMap and EllenBinTreePriorityQueue. ">ellen_bintree::type_traits</a> for explanation.</li>
</ul>
<p>It is possible to declare option-based tree with <a class="el" href="structcds_1_1container_1_1ellen__bintree_1_1make__set__traits.html" title="Metafunction converting option list to EllenBinTreeSet traits. ">ellen_bintree::make_set_traits</a> metafunction instead of <code>Traits</code> template argument. Template argument list <code>Options</code> of <a class="el" href="structcds_1_1container_1_1ellen__bintree_1_1make__set__traits.html" title="Metafunction converting option list to EllenBinTreeSet traits. ">ellen_bintree::make_set_traits</a> metafunction are:</p>
<ul>
<li><a class="el" href="namespacecds_1_1container_1_1ellen__bintree.html#a98c93af580558d5513af1b5a7214e4da" title="Typedef for cds::intrusive::ellen_bintree::key_extractor. ">ellen_bintree::key_extractor</a> - key extracting functor, mandatory option. The functor has the following prototype: <div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#aaf8ffece72c5181e330d3758a2a52e33">key_extractor</a> {</div>
<div class="line">    <span class="keywordtype">void</span> operator ()( Key&amp; dest, T <span class="keyword">const</span>&amp; src ) ;</div>
<div class="line">};</div>
</div><!-- fragment --> It should initialize <code>dest</code> key from <code>src</code> data. The functor is used to initialize internal nodes.</li>
<li><a class="el" href="structcds_1_1opt_1_1compare.html" title="[type-option] Option setter for key comparing ">opt::compare</a> - key compare functor. No default functor is provided. If the option is not specified, <code>opt::less</code> is used.</li>
<li><a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate ">opt::less</a> - specifies binary predicate used for key compare. At least <code>opt::compare</code> or <code>opt::less</code> should be defined.</li>
<li><a class="el" href="structcds_1_1opt_1_1item__counter.html" title="[type-option] Option setter for item counting ">opt::item_counter</a> - the type of item counting feature. Default is <a class="el" href="classcds_1_1atomicity_1_1empty__item__counter.html">atomicity::empty_item_counter</a> that is no item counting.</li>
<li><a class="el" href="structcds_1_1opt_1_1memory__model.html" title="[type-option] Option setter for C++ memory model ">opt::memory_model</a> - C++ memory ordering model. Can be <a class="el" href="structcds_1_1opt_1_1v_1_1relaxed__ordering.html" title="Relaxed memory ordering model. ">opt::v::relaxed_ordering</a> (relaxed memory model, the default) or <a class="el" href="structcds_1_1opt_1_1v_1_1sequential__consistent.html" title="Sequential consistent memory ordering model. ">opt::v::sequential_consistent</a> (sequentially consisnent memory model).</li>
<li><a class="el" href="structcds_1_1opt_1_1allocator.html" title="[type-option] Option setter for an allocator ">opt::allocator</a> - the allocator used for <a class="el" href="structcds_1_1container_1_1ellen__bintree_1_1node.html">leaf nodes</a> which contains data. Default is <a class="el" href="user__setup_2allocator_8h.html#ad5fb7e3cbe8cf24295f0ea3c165a2d82">CDS_DEFAULT_ALLOCATOR</a>.</li>
<li><a class="el" href="structcds_1_1opt_1_1node__allocator.html" title="[type-option] Option setter for node allocator ">opt::node_allocator</a> - the allocator used for internal nodes. Default is <a class="el" href="user__setup_2allocator_8h.html#ad5fb7e3cbe8cf24295f0ea3c165a2d82">CDS_DEFAULT_ALLOCATOR</a>.</li>
<li><a class="el" href="namespacecds_1_1container_1_1ellen__bintree.html#abf67b3b7bf47458b02ec081665adec0c" title="Typedef for cds::intrusive::ellen_bintree::update_desc_allocator. ">ellen_bintree::update_desc_allocator</a> - an allocator of <a class="el" href="namespacecds_1_1container_1_1ellen__bintree.html#ab6afc9f1cee19f542868b7cb3541400f">update descriptors</a>, default is <a class="el" href="user__setup_2allocator_8h.html#ad5fb7e3cbe8cf24295f0ea3c165a2d82">CDS_DEFAULT_ALLOCATOR</a>. Note that update descriptor is helping data structure with short lifetime and it is good candidate for pooling. The number of simultaneously existing descriptors is a relatively small number limited the number of threads working with the tree and RCU buffer size. Therefore, a bounded lock-free container like <code><a class="el" href="classcds_1_1container_1_1_vyukov_m_p_m_c_cycle_queue.html" title="Vyukov&#39;s MPMC bounded queue. ">cds::container::VyukovMPMCCycleQueue</a></code> is good choice for the free-list of update descriptors, see <a class="el" href="classcds_1_1memory_1_1vyukov__queue__pool.html" title="Free-list based on bounded lock-free queue cds::intrusive::VyukovMPMCCycleQueue. ">cds::memory::vyukov_queue_pool</a> free-list implementation. Also notice that size of update descriptor is not dependent on the type of data stored in the tree so single free-list object can be used for several EllenBinTree-based object.</li>
<li><a class="el" href="structcds_1_1opt_1_1stat.html" title="[type-option] Generic option setter for statisitcs ">opt::stat</a> - internal statistics. Available types: <a class="el" href="namespacecds_1_1container_1_1ellen__bintree.html#a26d24a3f54d0d1f97ddccfa2bb2d95a8" title="Typedef for cds::intrusive::ellen_bintree::stat. ">ellen_bintree::stat</a>, <a class="el" href="namespacecds_1_1container_1_1ellen__bintree.html#a995a1808963654d80b3175a55ffdfe9a" title="Typedef for cds::intrusive::ellen_bintree::empty_stat. ">ellen_bintree::empty_stat</a> (the default)</li>
<li><a class="el" href="structcds_1_1opt_1_1rcu__check__deadlock.html" title="[type-option] RCU check deadlock option setter ">opt::rcu_check_deadlock</a> - a deadlock checking policy. Default is <a class="el" href="structcds_1_1opt_1_1v_1_1rcu__throw__deadlock.html" title="opt::rcu_check_deadlock option value: throw a cds::urcu::rcu_deadlock exception when a deadlock detec...">opt::v::rcu_throw_deadlock</a></li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Before including <code>&lt;cds/container/ellen_bintree_set_rcu.h&gt;</code> you should include appropriate RCU header file, see <a class="el" href="namespacecds_1_1urcu.html#cds_urcu_gc">RCU type</a> for list of existing RCU class and corresponding header files.</dd></dl>
<p><a class="anchor" id="cds_container_EllenBinTreeSet_rcu_less"></a><b>Predicate requirements</b></p>
<p><a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate ">opt::less</a>, <a class="el" href="structcds_1_1opt_1_1compare.html" title="[type-option] Option setter for key comparing ">opt::compare</a> and other predicates using with member fuctions should accept at least parameters of type <code>T</code> and <code>Key</code> in any combination. For example, for <code>Foo</code> struct with <code>std::string</code> key field the appropiate <code>less</code> functor is: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Foo</div>
<div class="line">{</div>
<div class="line">    std::string m_strKey ;</div>
<div class="line">    ...</div>
<div class="line">} ;</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>less {</div>
<div class="line">    <span class="keywordtype">bool</span> operator()( Foo <span class="keyword">const</span>&amp; v1, Foo <span class="keyword">const</span>&amp; v2 )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{ <span class="keywordflow">return</span> v1.m_strKey &lt; v2.m_strKey ; }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> operator()( Foo <span class="keyword">const</span>&amp; v, std::string <span class="keyword">const</span>&amp; s )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{ <span class="keywordflow">return</span> v.m_strKey &lt; s ; }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> operator()( std::string <span class="keyword">const</span>&amp; s, Foo <span class="keyword">const</span>&amp; v )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{ <span class="keywordflow">return</span> s &lt; v.m_strKey ; }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Support comparing std::string and char const *</span></div>
<div class="line">    <span class="keywordtype">bool</span> operator()( std::string <span class="keyword">const</span>&amp; s, <span class="keywordtype">char</span> <span class="keyword">const</span> * p )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{ <span class="keywordflow">return</span> s.compare(p) &lt; 0 ; }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> operator()( Foo <span class="keyword">const</span>&amp; v, <span class="keywordtype">char</span> <span class="keyword">const</span> * p )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{ <span class="keywordflow">return</span> v.m_strKey.compare(p) &lt; 0 ; }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> operator()( <span class="keywordtype">char</span> <span class="keyword">const</span> * p, std::string <span class="keyword">const</span>&amp; s )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{ <span class="keywordflow">return</span> s.compare(p) &gt; 0; }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> operator()( <span class="keywordtype">char</span> <span class="keyword">const</span> * p, Foo <span class="keyword">const</span>&amp; v )<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{ <span class="keywordflow">return</span> v.m_strKey.compare(p) &gt; 0; }</div>
<div class="line">};</div>
</div><!-- fragment --> </div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="abbbbd5e33b6f10b8cae39096bdcf36b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html">cds::container::EllenBinTreeSet</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::check_consistency </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks internal consistency (not atomic, not thread-safe) </p>
<p>The debugging function to check internal consistency of the tree. </p>

</div>
</div>
<a class="anchor" id="a6441448b0697b4a01e45a9c541166526"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html">cds::container::EllenBinTreeSet</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the set (non-atomic) </p>
<p>The function unlink all items from the tree. The function is not atomic, thus, in multi-threaded environment with parallel insertions this sequence </p>
<div class="fragment"><div class="line">set.clear() ;</div>
<div class="line">assert( set.empty() ) ;</div>
</div><!-- fragment --><p> the assertion could be raised.</p>
<p>For each leaf the <a class="el" href="classcds_1_1intrusive_1_1_ellen_bin_tree_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#abc4c742b3e71e3e6f8c18088a94be9e8">disposer</a> will be called after unlinking.</p>
<p>RCU <code>synchronize</code> method can be called. RCU should not be locked. </p>

</div>
</div>
<a class="anchor" id="a7cd6718e5942f8f0b0ade3cf9ab730b1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html">cds::container::EllenBinTreeSet</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts data of type <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a17765b612bf9d824ad7b5408e8aa40bb">value_type</a> constructed with <code>std::forward&lt;Args&gt;(args)...</code> </p>
<p>Returns <code>true</code> if inserting successful, <code>false</code> otherwise.</p>
<p>RCU <code>synchronize</code> method can be called. RCU should not be locked.</p>
<dl class="section note"><dt>Note</dt><dd>This function is available only for compiler that supports variadic template and move semantics </dd></dl>

</div>
</div>
<a class="anchor" id="a8948039ed91e1ed4fbe6bcd0e8fc1d3d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;bool, bool&gt; <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html">cds::container::EllenBinTreeSet</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::ensure </td>
          <td>(</td>
          <td class="paramtype">const Q &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensures that the item exists in the set. </p>
<p>The operation performs inserting or changing data with lock-free manner.</p>
<p>If the <code>val</code> key not found in the set, then the new item created from <code>val</code> is inserted into the set. Otherwise, the functor <code>func</code> is called with the item found. The functor <code>Func</code> should be a function with signature: </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> func( <span class="keywordtype">bool</span> bNew, <a class="code" href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a17765b612bf9d824ad7b5408e8aa40bb">value_type</a>&amp; item, <span class="keyword">const</span> Q&amp; val ) ;</div>
</div><!-- fragment --><p> or a functor: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>my_functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <span class="keywordtype">bool</span> bNew, <a class="code" href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a17765b612bf9d824ad7b5408e8aa40bb">value_type</a>&amp; item, <span class="keyword">const</span> Q&amp; val ) ;</div>
<div class="line">};</div>
</div><!-- fragment --><p>with arguments:</p>
<ul>
<li><code>bNew</code> - <code>true</code> if the item has been inserted, <code>false</code> otherwise</li>
<li><code>item</code> - item of the set</li>
<li><code>val</code> - argument <code>key</code> passed into the <code>ensure</code> function</li>
</ul>
<p>The functor may change non-key fields of the <code>item</code>; however, <code>func</code> must guarantee that during changing no any other modifications could be made on this item by concurrent threads.</p>
<p>You may pass <code>func</code> argument by reference using <code>boost::ref</code>.</p>
<p>RCU <code>synchronize</code> method can be called. RCU should not be locked.</p>
<p>Returns <code> std::pair&lt;bool, bool&gt; </code> where <code>first</code> is true if operation is successfull, <code>second</code> is true if new item has been added or <code>false</code> if the item with <code>key</code> already is in the set. </p>

</div>
</div>
<a class="anchor" id="aabe916710687a8ffb333f79b3128ba09"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html">cds::container::EllenBinTreeSet</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete <code>key</code> from the set. </p>
<p><a class="anchor" id="cds_nonintrusive_EllenBinTreeSet_rcu_erase_val"></a> The item comparator should be able to compare the type <code>value_type</code> and the type <code>Q</code>.</p>
<p>RCU <code>synchronize</code> method can be called. RCU should not be locked.</p>
<p>Return <code>true</code> if key is found and deleted, <code>false</code> otherwise </p>

</div>
</div>
<a class="anchor" id="aa5d79aa56cf05370278f2defb9594b90"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html">cds::container::EllenBinTreeSet</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete <code>key</code> from the set. </p>
<p><a class="anchor" id="cds_nonintrusive_EllenBinTreeSet_rcu_erase_func"></a> The function searches an item with key <code>key</code>, calls <code>f</code> functor and deletes the item. If <code>key</code> is not found, the functor is not called.</p>
<p>The functor <code>Func</code> interface: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>extractor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()(<a class="code" href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a17765b612bf9d824ad7b5408e8aa40bb">value_type</a> <span class="keyword">const</span>&amp; val) ;</div>
<div class="line">};</div>
</div><!-- fragment --><p> The functor may be passed by reference using <code>boost:ref</code></p>
<p>Since the key of <a class="el" href="classcds_1_1container_1_1_michael_hash_set.html" title="Michael&#39;s hash set. ">MichaelHashSet</a>'s <code>value_type</code> is not explicitly specified, template parameter <code>Q</code> defines the key type searching in the list. The list item comparator should be able to compare the type <code>T</code> of list item and the type <code>Q</code>.</p>
<p>RCU <code>synchronize</code> method can be called. RCU should not be locked.</p>
<p>Return <code>true</code> if key is found and deleted, <code>false</code> otherwise</p>
<p>See also: <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#aabe916710687a8ffb333f79b3128ba09">erase</a> </p>

</div>
</div>
<a class="anchor" id="ae4dee540ea9a589af75496c5ecc5e0c7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html">cds::container::EllenBinTreeSet</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the set using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#cds_nonintrusive_EllenBinTreeSet_rcu_erase_val">erase(Q const&amp;)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the set. </p>

</div>
</div>
<a class="anchor" id="a541d19627182f19187d6cec90363f565"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html">cds::container::EllenBinTreeSet</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the set using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#cds_nonintrusive_EllenBinTreeSet_rcu_erase_func">erase(Q const&amp;, Func)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the set. </p>

</div>
</div>
<a class="anchor" id="aabbd48c190391566738580f0ab9d57c5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html">cds::container::EllenBinTreeSet</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::extract_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a17765b612bf9d824ad7b5408e8aa40bb">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>dest</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts an item with maximal key from the set. </p>
<p>If the set is not empty, the function returns <code>true</code>, <code>dest</code> contains the copy of maximum value (assignment operator is called for <code>value_type</code>). If the set is empty, the function returns <code>false</code>, <code>dest</code> is left unchanged.</p>
<dl class="section note"><dt>Note</dt><dd>Due the concurrent nature of the set, the function extracts <em>nearly</em> maximal key. It means that the function gets rightmost leaf of the tree and tries to unlink it. During unlinking, a concurrent thread may insert an item with key great than leftmost item's key. So, the function returns the item with maximum key at the moment of tree traversing.</dd></dl>
<p>RCU <code>synchronize</code> method can be called. RCU should not be locked. </p>

</div>
</div>
<a class="anchor" id="a7b0f714441431bff46adcbccbfa963e6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html">cds::container::EllenBinTreeSet</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::extract_max </td>
          <td>(</td>
          <td class="paramtype">Q &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts an item with maximal key from the set. </p>
<p>If the set is not empty, the function returns <code>true</code>, <code>f</code> functor is called with value found. If the set is empty, the function returns <code>false</code>, <code>f</code> functor is not called, <code>dest</code> is left unchanged.</p>
<p>The functor <code>Func</code> interface is: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>extract_functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( Q&amp; dest, <a class="code" href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a17765b612bf9d824ad7b5408e8aa40bb">value_type</a>&amp; valueFound ) ;</div>
<div class="line">};</div>
</div><!-- fragment --><p> <code>f</code> can be passed by value or by reference using <code>boost::ref</code> or cds::ref.</p>
<dl class="section note"><dt>Note</dt><dd>Due the concurrent nature of the set, the function extracts <em>nearly</em> maximal key. It means that the function gets rightmost leaf of the tree and tries to unlink it. During unlinking, a concurrent thread may insert an item with key great than leftmost item's key. So, the function returns the item with maximum key at the moment of tree traversing.</dd></dl>
<p>RCU <code>synchronize</code> method can be called. RCU should not be locked. </p>

</div>
</div>
<a class="anchor" id="a40f7d499a57854052426e98baf0a1935"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html">cds::container::EllenBinTreeSet</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::extract_min </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a17765b612bf9d824ad7b5408e8aa40bb">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>dest</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts an item with minimal key from the set. </p>
<p>If the set is not empty, the function returns <code>true</code>, <code>dest</code> contains the copy of minimum value (assignment operator is called for <code>value_type</code>). If the set is empty, the function returns <code>false</code>, <code>dest</code> is left unchanged.</p>
<dl class="section note"><dt>Note</dt><dd>Due the concurrent nature of the set, the function extracts <em>nearly</em> minimum key. It means that the function gets leftmost leaf of the tree and tries to unlink it. During unlinking, a concurrent thread may insert an item with key less than leftmost item's key. So, the function returns the item with minimum key at the moment of tree traversing.</dd></dl>
<p>RCU <code>synchronize</code> method can be called. RCU should not be locked. </p>

</div>
</div>
<a class="anchor" id="a18aaa14bbc8ba94175873d39384d1459"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html">cds::container::EllenBinTreeSet</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::extract_min </td>
          <td>(</td>
          <td class="paramtype">Q &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts an item with minimal key from the set. </p>
<p>If the set is not empty, the function returns <code>true</code>, <code>f</code> functor is called with value found. If the set is empty, the function returns <code>false</code>, <code>f</code> functor is not called, <code>dest</code> is left unchanged.</p>
<p>The functor <code>Func</code> interface is: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>extract_functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( Q&amp; dest, <a class="code" href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a17765b612bf9d824ad7b5408e8aa40bb">value_type</a>&amp; valueFound ) ;</div>
<div class="line">};</div>
</div><!-- fragment --><p> <code>f</code> can be passed by value or by reference using <code>boost::ref</code> or cds::ref.</p>
<dl class="section note"><dt>Note</dt><dd>Due the concurrent nature of the set, the function extracts <em>nearly</em> minimum key. It means that the function gets leftmost leaf of the tree and tries to unlink it. During unlinking, a concurrent thread may insert an item with key less than leftmost item's key. So, the function returns the item with minimum key at the moment of tree traversing.</dd></dl>
<p>RCU <code>synchronize</code> method can be called. RCU should not be locked. </p>

</div>
</div>
<a class="anchor" id="a2aa17ccda5d27ea648109d063eea9a7f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html">cds::container::EllenBinTreeSet</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::find </td>
          <td>(</td>
          <td class="paramtype">Q &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the key <code>val</code>. </p>
<p><a class="anchor" id="cds_nonintrusive_EllenBinTreeSet_rcu_find_func"></a> The function searches the item with key equal to <code>val</code> and calls the functor <code>f</code> for item found. The interface of <code>Func</code> functor is: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a17765b612bf9d824ad7b5408e8aa40bb">value_type</a>&amp; item, Q&amp; val ) ;</div>
<div class="line">};</div>
</div><!-- fragment --><p> where <code>item</code> is the item found, <code>val</code> is the <code>find</code> function argument.</p>
<p>You may pass <code>f</code> argument by reference using <code>boost::ref</code> or cds::ref.</p>
<p>The functor may change non-key fields of <code>item</code>. Note that the functor is only guarantee that <code>item</code> cannot be disposed during functor is executing. The functor does not serialize simultaneous access to the set's <code>item</code>. If such access is possible you must provide your own synchronization schema on item level to exclude unsafe item modifications.</p>
<p>The <code>val</code> argument is non-const since it can be used as <code>f</code> functor destination i.e., the functor can modify both arguments.</p>
<p>Note the hash functor specified for class <code>Traits</code> template parameter should accept a parameter of type <code>Q</code> that may be not the same as <code>value_type</code>.</p>
<p>The function applies RCU lock internally.</p>
<p>The function returns <code>true</code> if <code>val</code> is found, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a50e3a875583aff66423bc40df8f268d3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html">cds::container::EllenBinTreeSet</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::find </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the key <code>val</code>. </p>
<p><a class="anchor" id="cds_nonintrusive_EllenBinTreeSet_rcu_find_cfunc"></a> The function searches the item with key equal to <code>val</code> and calls the functor <code>f</code> for item found. The interface of <code>Func</code> functor is: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a17765b612bf9d824ad7b5408e8aa40bb">value_type</a>&amp; item, Q <span class="keyword">const</span>&amp; val ) ;</div>
<div class="line">};</div>
</div><!-- fragment --><p> where <code>item</code> is the item found, <code>val</code> is the <code>find</code> function argument.</p>
<p>You may pass <code>f</code> argument by reference using <code>boost::ref</code> or cds::ref.</p>
<p>The functor may change non-key fields of <code>item</code>. Note that the functor is only guarantee that <code>item</code> cannot be disposed during functor is executing. The functor does not serialize simultaneous access to the set's <code>item</code>. If such access is possible you must provide your own synchronization schema on item level to exclude unsafe item modifications.</p>
<p>Note the hash functor specified for class <code>Traits</code> template parameter should accept a parameter of type <code>Q</code> that may be not the same as <code>value_type</code>.</p>
<p>The function applies RCU lock internally.</p>
<p>The function returns <code>true</code> if <code>val</code> is found, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a5fc3ec7ae35a1f71b2763db660c007e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html">cds::container::EllenBinTreeSet</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::find </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the key <code>val</code>. </p>
<p><a class="anchor" id="cds_nonintrusive_EllenBinTreeSet_rcu_find_val"></a> The function searches the item with key equal to <code>val</code> and returns <code>true</code> if it is found, and <code>false</code> otherwise.</p>
<p>Note the hash functor specified for class <code>Traits</code> template parameter should accept a parameter of type <code>Q</code> that may be not the same as <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a17765b612bf9d824ad7b5408e8aa40bb">value_type</a>.</p>
<p>The function applies RCU lock internally. </p>

</div>
</div>
<a class="anchor" id="ae35ad36ab80db2ec9ec06d66871dccfe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html">cds::container::EllenBinTreeSet</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::find_with </td>
          <td>(</td>
          <td class="paramtype">Q &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the key <code>val</code> using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#cds_nonintrusive_EllenBinTreeSet_rcu_find_func">find(Q&amp;, Func)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the set. </p>

</div>
</div>
<a class="anchor" id="a187eadb318bb65cf3b978d9322ab45b1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html">cds::container::EllenBinTreeSet</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::find_with </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the key <code>val</code> using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#cds_nonintrusive_EllenBinTreeSet_rcu_find_cfunc">find(Q const&amp;, Func)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the set. </p>

</div>
</div>
<a class="anchor" id="a6c11cf2779637e38558bb999720c18e7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Less &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html">cds::container::EllenBinTreeSet</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::find_with </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the key <code>val</code> using <code>pred</code> predicate for searching. </p>
<p>The function is an analog of <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#cds_nonintrusive_EllenBinTreeSet_rcu_find_val">find(Q const&amp;)</a> but <code>pred</code> is used for key comparing. <code>Less</code> functor has the interface like <code>std::less</code>. <code>Less</code> must imply the same element order as the comparator used for building the set. </p>

</div>
</div>
<a class="anchor" id="a247d812b16ef0d80721152d7917dbb40"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html">cds::container::EllenBinTreeSet</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node. </p>
<p>The function creates a node with copy of <code>val</code> value and then inserts the node created into the set.</p>
<p>The type <code>Q</code> should contain at least the complete key for the node. The object of <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a17765b612bf9d824ad7b5408e8aa40bb">value_type</a> should be constructible from a value of type <code>Q</code>. In trivial case, <code>Q</code> is equal to <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a17765b612bf9d824ad7b5408e8aa40bb">value_type</a>.</p>
<p>RCU <code>synchronize</code> method can be called. RCU should not be locked.</p>
<p>Returns <code>true</code> if <code>val</code> is inserted into the set, <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a0f13e865f9b3ede54a81ecd7299e5168"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html">cds::container::EllenBinTreeSet</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">Q const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node. </p>
<p>The function allows to split creating of new item into two part:</p>
<ul>
<li>create item with key only</li>
<li>insert new item into the set</li>
<li>if inserting is success, calls <code>f</code> functor to initialize value-fields of <code>val</code>.</li>
</ul>
<p>The functor signature is: </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> func( <a class="code" href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a17765b612bf9d824ad7b5408e8aa40bb">value_type</a>&amp; val ) ;</div>
</div><!-- fragment --><p> where <code>val</code> is the item inserted. User-defined functor <code>f</code> should guarantee that during changing <code>val</code> no any other changes could be made on this set's item by concurrent threads. The user-defined functor is called only if the inserting is success. It may be passed by reference using <code>boost::ref</code></p>
<p>RCU <code>synchronize</code> method can be called. RCU should not be locked. </p>

</div>
</div>
<a class="anchor" id="a141ba970f7bea87401c9bcf307309bf6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RCU , typename Key , typename T , class Traits  = ellen_bintree::type_traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set.html">cds::container::EllenBinTreeSet</a>&lt; cds::urcu::gc&lt; RCU &gt;, Key, T, Traits &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns item count in the set. </p>
<p>Only leaf nodes containing user data are counted.</p>
<p>The value returned depends on item counter type provided by <code>Traits</code> template parameter. If it is <a class="el" href="classcds_1_1atomicity_1_1empty__item__counter.html" title="Empty item counter. ">atomicity::empty_item_counter</a> this function always returns 0. Therefore, the function is not suitable for checking the tree emptiness, use <a class="el" href="classcds_1_1container_1_1_ellen_bin_tree_set_3_01cds_1_1urcu_1_1gc_3_01_r_c_u_01_4_00_01_key_00_01_t_00_01_traits_01_4.html#a04e7c1113b331c49abb77ce011bb4e90">empty</a> member function for this purpose. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>cds/container/ellen_bintree_set_rcu.h</li>
</ul>
</div><!-- contents -->
		<hr/>
		<div align="right">
			<b>cds</b> <b>1.5.0</b> 
			Developed by <i>Maxim Khiszinsky aka khizmax</i> 2007 - 2012
			<br/>
			<i>Autogenerated Sat Dec 28 2013 15:04:02 by Doxygen 1.8.5</i>
		</div>
	</BODY>
</HTML>
