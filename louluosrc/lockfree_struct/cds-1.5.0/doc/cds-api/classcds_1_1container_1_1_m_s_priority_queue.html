<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>cds: cds::container::MSPriorityQueue&lt; T, Traits &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">cds
   &#160;<span id="projectnumber">1.5.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecds.html">cds</a></li><li class="navelem"><a class="el" href="namespacecds_1_1container.html">container</a></li><li class="navelem"><a class="el" href="classcds_1_1container_1_1_m_s_priority_queue.html">MSPriorityQueue</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">cds::container::MSPriorityQueue&lt; T, Traits &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__cds__nonintrusive__priority__queue.html">Priority queue</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Michael &amp; Scott array-based lock-based concurrent priority queue heap.  
 <a href="classcds_1_1container_1_1_m_s_priority_queue.html#details">More...</a></p>

<p><code>#include &lt;cds/container/mspriority_queue.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cds::container::MSPriorityQueue&lt; T, Traits &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcds_1_1container_1_1_m_s_priority_queue.png" usemap="#cds::container::MSPriorityQueue&lt; T, Traits &gt;_map" alt=""/>
  <map id="cds::container::MSPriorityQueue&lt; T, Traits &gt;_map" name="cds::container::MSPriorityQueue&lt; T, Traits &gt;_map">
<area href="structcds_1_1bounded__container.html" title="Bounded container. " alt="cds::bounded_container" shape="rect" coords="0,0,266,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcds_1_1container_1_1_m_s_priority_queue_1_1node.html">node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Heap item type.  <a href="structcds_1_1container_1_1_m_s_priority_queue_1_1node.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:acb562aaacd6c7d5a402f55cdb8ded2cd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acb562aaacd6c7d5a402f55cdb8ded2cd"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_m_s_priority_queue.html#acb562aaacd6c7d5a402f55cdb8ded2cd">value_type</a></td></tr>
<tr class="memdesc:acb562aaacd6c7d5a402f55cdb8ded2cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value type stored in the queue. <br/></td></tr>
<tr class="separator:acb562aaacd6c7d5a402f55cdb8ded2cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac52e022dd16a8d125537c3da84468b44"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac52e022dd16a8d125537c3da84468b44"></a>
typedef Traits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_m_s_priority_queue.html#ac52e022dd16a8d125537c3da84468b44">options</a></td></tr>
<tr class="memdesc:ac52e022dd16a8d125537c3da84468b44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits template parameter. <br/></td></tr>
<tr class="separator:ac52e022dd16a8d125537c3da84468b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7849470ec7b782097530ab00e43dfaf4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7849470ec7b782097530ab00e43dfaf4"></a>
typedef implementation_defined&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_m_s_priority_queue.html#a7849470ec7b782097530ab00e43dfaf4">key_comparator</a></td></tr>
<tr class="memdesc:a7849470ec7b782097530ab00e43dfaf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">priority comparing functor based on <a class="el" href="structcds_1_1opt_1_1compare.html" title="[type-option] Option setter for key comparing ">opt::compare</a> and <a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate ">opt::less</a> option setter. <br/></td></tr>
<tr class="separator:a7849470ec7b782097530ab00e43dfaf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fff4fc0a53724c30b3439246a185551"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7fff4fc0a53724c30b3439246a185551"></a>
typedef options::lock_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_m_s_priority_queue.html#a7fff4fc0a53724c30b3439246a185551">lock_type</a></td></tr>
<tr class="memdesc:a7fff4fc0a53724c30b3439246a185551"><td class="mdescLeft">&#160;</td><td class="mdescRight">heap's size lock type <br/></td></tr>
<tr class="separator:a7fff4fc0a53724c30b3439246a185551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aece946b184b66992f3f60b70d5e11dab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aece946b184b66992f3f60b70d5e11dab"></a>
typedef options::back_off&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_m_s_priority_queue.html#aece946b184b66992f3f60b70d5e11dab">back_off</a></td></tr>
<tr class="memdesc:aece946b184b66992f3f60b70d5e11dab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Back-off strategy. <br/></td></tr>
<tr class="separator:aece946b184b66992f3f60b70d5e11dab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a679841538bed3f0794330dee5bd83bfb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a679841538bed3f0794330dee5bd83bfb"></a>
typedef options::swap_policy&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_m_s_priority_queue.html#a679841538bed3f0794330dee5bd83bfb">swap_policy</a></td></tr>
<tr class="memdesc:a679841538bed3f0794330dee5bd83bfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap policy for type <code>T</code>. <br/></td></tr>
<tr class="separator:a679841538bed3f0794330dee5bd83bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa48fbe6cbe23c7bd9fada5168390a73c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa48fbe6cbe23c7bd9fada5168390a73c"></a>
typedef options::move_policy&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_m_s_priority_queue.html#aa48fbe6cbe23c7bd9fada5168390a73c">move_policy</a></td></tr>
<tr class="memdesc:aa48fbe6cbe23c7bd9fada5168390a73c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move policy for type <code>T</code>. <br/></td></tr>
<tr class="separator:aa48fbe6cbe23c7bd9fada5168390a73c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55cb16438f717bbeb903ffd6c6363391"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a55cb16438f717bbeb903ffd6c6363391"></a>
typedef <br class="typebreak"/>
options::buffer::template <br class="typebreak"/>
rebind&lt; <a class="el" href="structcds_1_1container_1_1_m_s_priority_queue_1_1node.html">node</a> &gt;::other&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_m_s_priority_queue.html#a55cb16438f717bbeb903ffd6c6363391">buffer_type</a></td></tr>
<tr class="memdesc:a55cb16438f717bbeb903ffd6c6363391"><td class="mdescLeft">&#160;</td><td class="mdescRight">Heap array buffer type. <br/></td></tr>
<tr class="separator:a55cb16438f717bbeb903ffd6c6363391"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa8a953b5906266a31d8a14deb2c48ca3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_m_s_priority_queue.html#aa8a953b5906266a31d8a14deb2c48ca3">MSPriorityQueue</a> (size_t nCapacity)</td></tr>
<tr class="memdesc:aa8a953b5906266a31d8a14deb2c48ca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs empty priority queue.  <a href="#aa8a953b5906266a31d8a14deb2c48ca3">More...</a><br/></td></tr>
<tr class="separator:aa8a953b5906266a31d8a14deb2c48ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d92e0a06a144bd9ff322ebbcf8003c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a24d92e0a06a144bd9ff322ebbcf8003c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_m_s_priority_queue.html#a24d92e0a06a144bd9ff322ebbcf8003c">~MSPriorityQueue</a> ()</td></tr>
<tr class="memdesc:a24d92e0a06a144bd9ff322ebbcf8003c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears priority queue and destructs the object. <br/></td></tr>
<tr class="separator:a24d92e0a06a144bd9ff322ebbcf8003c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac767ac91122f6aef248add71c079155a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_m_s_priority_queue.html#ac767ac91122f6aef248add71c079155a">push</a> (<a class="el" href="classcds_1_1container_1_1_m_s_priority_queue.html#acb562aaacd6c7d5a402f55cdb8ded2cd">value_type</a> const &amp;val)</td></tr>
<tr class="memdesc:ac767ac91122f6aef248add71c079155a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a item into priority queue.  <a href="#ac767ac91122f6aef248add71c079155a">More...</a><br/></td></tr>
<tr class="separator:ac767ac91122f6aef248add71c079155a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b82c3b481b9e5c595fde3f3770d789c"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a4b82c3b481b9e5c595fde3f3770d789c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_m_s_priority_queue.html#a4b82c3b481b9e5c595fde3f3770d789c">emplace</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a4b82c3b481b9e5c595fde3f3770d789c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a item into priority queue.  <a href="#a4b82c3b481b9e5c595fde3f3770d789c">More...</a><br/></td></tr>
<tr class="separator:a4b82c3b481b9e5c595fde3f3770d789c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76e5314b3736bf646c92f9bde9c17210"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_m_s_priority_queue.html#a76e5314b3736bf646c92f9bde9c17210">pop</a> (<a class="el" href="classcds_1_1container_1_1_m_s_priority_queue.html#acb562aaacd6c7d5a402f55cdb8ded2cd">value_type</a> &amp;dest)</td></tr>
<tr class="memdesc:a76e5314b3736bf646c92f9bde9c17210"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts item with high priority.  <a href="#a76e5314b3736bf646c92f9bde9c17210">More...</a><br/></td></tr>
<tr class="separator:a76e5314b3736bf646c92f9bde9c17210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49200417203d05ca15d113384754b49d"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename MoveFunc &gt; </td></tr>
<tr class="memitem:a49200417203d05ca15d113384754b49d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_m_s_priority_queue.html#a49200417203d05ca15d113384754b49d">pop_with</a> (Q &amp;dest, MoveFunc f)</td></tr>
<tr class="memdesc:a49200417203d05ca15d113384754b49d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts item with high priority.  <a href="#a49200417203d05ca15d113384754b49d">More...</a><br/></td></tr>
<tr class="separator:a49200417203d05ca15d113384754b49d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7b64621b14df78c31b3d46fc477e43c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_m_s_priority_queue.html#ac7b64621b14df78c31b3d46fc477e43c">clear</a> ()</td></tr>
<tr class="memdesc:ac7b64621b14df78c31b3d46fc477e43c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the queue (not atomic)  <a href="#ac7b64621b14df78c31b3d46fc477e43c">More...</a><br/></td></tr>
<tr class="separator:ac7b64621b14df78c31b3d46fc477e43c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91353d499b623983c87dd4ba3acc34c6"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:a91353d499b623983c87dd4ba3acc34c6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_m_s_priority_queue.html#a91353d499b623983c87dd4ba3acc34c6">clear_with</a> (Func f)</td></tr>
<tr class="memdesc:a91353d499b623983c87dd4ba3acc34c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the queue (not atomic)  <a href="#a91353d499b623983c87dd4ba3acc34c6">More...</a><br/></td></tr>
<tr class="separator:a91353d499b623983c87dd4ba3acc34c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2782ed1a8e7a97fd1ac0d9ab5cc61f6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab2782ed1a8e7a97fd1ac0d9ab5cc61f6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_m_s_priority_queue.html#ab2782ed1a8e7a97fd1ac0d9ab5cc61f6">empty</a> () const </td></tr>
<tr class="memdesc:ab2782ed1a8e7a97fd1ac0d9ab5cc61f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks is the priority queue is empty. <br/></td></tr>
<tr class="separator:ab2782ed1a8e7a97fd1ac0d9ab5cc61f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab34dc6d4eca58c27a7e4fa422b23c857"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab34dc6d4eca58c27a7e4fa422b23c857"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_m_s_priority_queue.html#ab34dc6d4eca58c27a7e4fa422b23c857">full</a> () const </td></tr>
<tr class="memdesc:ab34dc6d4eca58c27a7e4fa422b23c857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the priority queue is full. <br/></td></tr>
<tr class="separator:ab34dc6d4eca58c27a7e4fa422b23c857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0791f4a16911939951a6c9ea9d6c2717"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0791f4a16911939951a6c9ea9d6c2717"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_m_s_priority_queue.html#a0791f4a16911939951a6c9ea9d6c2717">size</a> () const </td></tr>
<tr class="memdesc:a0791f4a16911939951a6c9ea9d6c2717"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns current size of priority queue. <br/></td></tr>
<tr class="separator:a0791f4a16911939951a6c9ea9d6c2717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea726b2cf1d3982c0f5b533d299eff78"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea726b2cf1d3982c0f5b533d299eff78"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_m_s_priority_queue.html#aea726b2cf1d3982c0f5b533d299eff78">capacity</a> () const </td></tr>
<tr class="memdesc:aea726b2cf1d3982c0f5b533d299eff78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return capacity of the priority queue. <br/></td></tr>
<tr class="separator:aea726b2cf1d3982c0f5b533d299eff78"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a349488b24635e03ee20bdf53e5c80260"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a349488b24635e03ee20bdf53e5c80260"></a>
item_counter_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_m_s_priority_queue.html#a349488b24635e03ee20bdf53e5c80260">m_ItemCounter</a></td></tr>
<tr class="memdesc:a349488b24635e03ee20bdf53e5c80260"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counter. <br/></td></tr>
<tr class="separator:a349488b24635e03ee20bdf53e5c80260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32d194d81a4d47eda841668f5796b064"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a32d194d81a4d47eda841668f5796b064"></a>
<a class="el" href="classcds_1_1container_1_1_m_s_priority_queue.html#a7fff4fc0a53724c30b3439246a185551">lock_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_m_s_priority_queue.html#a32d194d81a4d47eda841668f5796b064">m_Lock</a></td></tr>
<tr class="memdesc:a32d194d81a4d47eda841668f5796b064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Heap's size lock. <br/></td></tr>
<tr class="separator:a32d194d81a4d47eda841668f5796b064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7516f937f3383e67470803251d05d6c2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7516f937f3383e67470803251d05d6c2"></a>
<a class="el" href="classcds_1_1container_1_1_m_s_priority_queue.html#a55cb16438f717bbeb903ffd6c6363391">buffer_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_m_s_priority_queue.html#a7516f937f3383e67470803251d05d6c2">m_Heap</a></td></tr>
<tr class="memdesc:a7516f937f3383e67470803251d05d6c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Heap array. <br/></td></tr>
<tr class="separator:a7516f937f3383e67470803251d05d6c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, class Traits&gt;<br/>
class cds::container::MSPriorityQueue&lt; T, Traits &gt;</h3>

<p>Michael &amp; Scott array-based lock-based concurrent priority queue heap. </p>
<p>Source:</p>
<ul>
<li>[1996] G.Hunt, M.Michael, S. Parthasarathy, M.Scott "An efficient algorithm for concurrent priority queue heaps"</li>
</ul>
<p><code>MSPriorityQueue</code> augments the standard array-based heap data structure with a mutual-exclusion lock on the heap's size and locks on each node in the heap. Each node also has a tag that indicates whether it is empty, valid, or in a transient state due to an update to the heap by an inserting thread. The algorithm allows concurrent insertions and deletions in opposite directions, without risking deadlock and without the need for special server threads. It also uses a "bit-reversal" technique to scatter accesses across the fringe of the tree to reduce contention. On large heaps the algorithm achieves significant performance improvements over serialized single-lock algorithm, for various insertion/deletion workloads. For small heaps it still performs well, but not as well as single-lock algorithm.</p>
<p>Template parameters:</p>
<ul>
<li><code>T</code> - type to be stored in the list. The priority is a part of <code>T</code> type.</li>
<li><code>Traits</code> - type traits. See <a class="el" href="structcds_1_1container_1_1mspriority__queue_1_1type__traits.html" title="Type traits for MSPriorityQueue. ">mspriority_queue::type_traits</a> for explanation.</li>
</ul>
<p>It is possible to declare option-based queue with <a class="el" href="structcds_1_1container_1_1mspriority__queue_1_1make__traits.html" title="Metafunction converting option list to traits. ">cds::container::mspriority_queue::make_traits</a> metafunction instead of <code>Traits</code> template argument. Template argument list <code>Options</code> of <code>cds::container::mspriority_queue::make_traits</code> metafunction are:</p>
<ul>
<li><a class="el" href="structcds_1_1opt_1_1buffer.html" title="[type-option] Option setter for user-provided plain buffer ">opt::buffer</a> - the buffer type for heap array. Possible type are: <a class="el" href="classcds_1_1opt_1_1v_1_1static__buffer.html" title="Static buffer (opt::buffer option) ">opt::v::static_buffer</a>, <a class="el" href="classcds_1_1opt_1_1v_1_1dynamic__buffer.html" title="Dynamically allocated buffer. ">opt::v::dynamic_buffer</a>. Default is <code>opt::v::dynamic_buffer</code>. At <code>MSPriorityQueue</code> class instantiation, the <code>buffer::rebind</code> member metafunction is called to change type of values stored in the buffer. So, you may specify any type of values here.</li>
<li><a class="el" href="structcds_1_1opt_1_1compare.html" title="[type-option] Option setter for key comparing ">opt::compare</a> - priority compare functor. No default functor is provided. If the option is not specified, the <a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate ">opt::less</a> is used.</li>
<li><a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate ">opt::less</a> - specifies binary predicate used for priority compare. Default is <code>std::less&lt;T&gt;</code>.</li>
<li><a class="el" href="structcds_1_1opt_1_1lock__type.html" title="[type-option] Option setter specifies lock class ">opt::lock_type</a> - lock type. Default is <a class="el" href="namespacecds_1_1lock.html#a15a8b3acda5ee790986ba12eb894eccf" title="Spin-lock implementation default for the current platform. ">cds::lock::Spin</a>.</li>
<li><a class="el" href="structcds_1_1opt_1_1back__off.html" title="[type-option] Back-off strategy option setter ">opt::back_off</a> - back-off strategy. Default is <a class="el" href="structcds_1_1backoff_1_1yield.html" title="Switch to another thread (yield). Good for thread preemption architecture. ">cds::backoff::yield</a></li>
<li><a class="el" href="structcds_1_1opt_1_1swap__policy.html" title="Swap policy option. ">opt::swap_policy</a> - item swapping policy used to heapify. Default is <a class="el" href="structcds_1_1opt_1_1v_1_1default__swap__policy.html" title="Default swap policy (see opt::swap_policy option) ">opt::v::default_swap_policy</a> that is a wrapper for <code> std::swap&lt;T&gt; </code> algorithm.</li>
<li><a class="el" href="structcds_1_1opt_1_1move__policy.html" title="Move policy option. ">opt::move_policy</a> - policy for moving item's value. Default is <a class="el" href="structcds_1_1opt_1_1v_1_1assignment__move__policy.html" title="Move policy based on assignment operator ">opt::v::assignment_move_policy</a>. If the compiler supports move semantics it would be better to specify the move policy based on move semantics feature for type <code>T</code>.</li>
</ul>
<dl class="section user"><dt>Usage</dt><dd></dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aa8a953b5906266a31d8a14deb2c48ca3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_m_s_priority_queue.html">cds::container::MSPriorityQueue</a>&lt; T, Traits &gt;::<a class="el" href="classcds_1_1container_1_1_m_s_priority_queue.html">MSPriorityQueue</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nCapacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs empty priority queue. </p>
<p>For <a class="el" href="classcds_1_1opt_1_1v_1_1static__buffer.html" title="Static buffer (opt::buffer option) ">cds::opt::v::static_buffer</a> the <code>nCapacity</code> parameter is ignored. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ac7b64621b14df78c31b3d46fc477e43c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcds_1_1container_1_1_m_s_priority_queue.html">cds::container::MSPriorityQueue</a>&lt; T, Traits &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the queue (not atomic) </p>
<p>This function is no atomic, but thread-safe </p>

</div>
</div>
<a class="anchor" id="a91353d499b623983c87dd4ba3acc34c6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Traits&gt; </div>
<div class="memtemplate">
template&lt;typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcds_1_1container_1_1_m_s_priority_queue.html">cds::container::MSPriorityQueue</a>&lt; T, Traits &gt;::clear_with </td>
          <td>(</td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the queue (not atomic) </p>
<p>This function is no atomic, but thread-safe.</p>
<p>For each item removed the functor <code>f</code> is called. <code>Func</code> interface is: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>clear_functor</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <a class="code" href="classcds_1_1container_1_1_m_s_priority_queue.html#acb562aaacd6c7d5a402f55cdb8ded2cd">value_type</a>&amp; item ) ;</div>
<div class="line">};</div>
</div><!-- fragment --><p> A lambda function or a function pointer can be used as <code>f</code>. </p>

</div>
</div>
<a class="anchor" id="a4b82c3b481b9e5c595fde3f3770d789c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Traits&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_m_s_priority_queue.html">cds::container::MSPriorityQueue</a>&lt; T, Traits &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a item into priority queue. </p>
<p>If the priority queue is full, the function returns <code>false</code>, no item has been added. Otherwise, the function inserts a new item created from <code>args</code> arguments into the heap and returns <code>true</code>.</p>
<p>The function is available only for compilers supporting variable template and move semantics C++11 feature. </p>

</div>
</div>
<a class="anchor" id="a76e5314b3736bf646c92f9bde9c17210"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_m_s_priority_queue.html">cds::container::MSPriorityQueue</a>&lt; T, Traits &gt;::pop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1container_1_1_m_s_priority_queue.html#acb562aaacd6c7d5a402f55cdb8ded2cd">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>dest</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts item with high priority. </p>
<p>If the priority queue is empty, the function returns <code>false</code>. Otherwise, it returns <code>true</code> and <code>dest</code> contains the copy of extracted item. The item is deleted from the heap.</p>
<p>The function uses <a class="el" href="classcds_1_1container_1_1_m_s_priority_queue.html#aa48fbe6cbe23c7bd9fada5168390a73c">move_policy</a> to move extracted value from the heap's top to <code>dest</code>. </p>

</div>
</div>
<a class="anchor" id="a49200417203d05ca15d113384754b49d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename MoveFunc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_m_s_priority_queue.html">cds::container::MSPriorityQueue</a>&lt; T, Traits &gt;::pop_with </td>
          <td>(</td>
          <td class="paramtype">Q &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MoveFunc&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts item with high priority. </p>
<p>If the priority queue is empty, the function returns <code>false</code>. Otherwise, it returns <code>true</code> and <code>dest</code> contains the copy of extracted item. The item is deleted from the heap.</p>
<p>The function uses <code>MoveFunc</code> <code>f</code> to move extracted value from the heap's top to <code>dest</code>. The interface of <code>MoveFunc</code> is: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>move_funcor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( Q&amp; dest, T&amp; src ) ;</div>
<div class="line">};</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ac767ac91122f6aef248add71c079155a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class Traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_m_s_priority_queue.html">cds::container::MSPriorityQueue</a>&lt; T, Traits &gt;::push </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1container_1_1_m_s_priority_queue.html#acb562aaacd6c7d5a402f55cdb8ded2cd">value_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a item into priority queue. </p>
<p>If the priority queue is full, the function returns <code>false</code>, no item has been added. Otherwise, the function inserts the copy of <code>val</code> into the heap and returns <code>true</code>.</p>
<p>The function use copy constructor to create new heap item from <code>val</code>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>cds/container/mspriority_queue.h</li>
</ul>
</div><!-- contents -->
		<hr/>
		<div align="right">
			<b>cds</b> <b>1.5.0</b> 
			Developed by <i>Maxim Khiszinsky aka khizmax</i> 2007 - 2012
			<br/>
			<i>Autogenerated Sat Dec 28 2013 15:04:03 by Doxygen 1.8.5</i>
		</div>
	</BODY>
</HTML>
